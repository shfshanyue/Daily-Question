[
  {
    "id": "MDU6SXNzdWU1MTYwNTcyNDA=",
    "number": 1,
    "title": "【Q001】网站开发中，如何实现图片的懒加载",
    "body": "网站开发中，如何实现图片的懒加载，随着 web 技术的发展，他有没有一些更好的方案",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTEzMzE0NQ==",
      "body": "懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片\r\n\r\n故问题拆分成两个：\r\n\r\n1. 如何判断图片出现在了当前视口 （即如何判断我们能够看到图片）\r\n2. 如何控制图片的加载\r\n\r\n## 方案一\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n`clientTop`，`offsetTop`，`clientHeight` 以及 `scrollTop` 各种关于图片的高度作比对\r\n\r\n这些高度都代表了什么意思？\r\n\r\n这我以前有可能是知道的，那时候我比较单纯，喜欢死磕。我现在想通了，背不过的东西就不要背了\r\n\r\n**所以它有一个问题：复杂琐碎不好理解！**\r\n\r\n仅仅知道它静态的高度还不够，我们还需要知道动态的\r\n\r\n**如何动态？监听 `window.scroll` 事件**\r\n\r\n### 如何控制图片的加载\r\n\r\n``` html\r\n<img data-src=\"shanyue.jpg\">\r\n```\r\n\r\n首先设置一个临时属性 `data-src`，控制加载时使用 `src` 代替 `data-src`\r\n\r\n## 方案二\r\n\r\n改进一下\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n引入一个新的 API， **`Element.getBoundingClientRect()` 方法返回元素的大小及其相对于视口的位置。**\r\n\r\n<img alt=\"getBoundingClientRect示例图\" src=\"https://mdn.mozillademos.org/files/15087/rect.png\">\r\n\r\n那如何判断图片出现在了当前视口呢，根据示例图示意，代码如下，这个就比较好理解了，就可以很容易地背会(就可以愉快地去面试了)。\r\n\r\n``` js\r\n// clientHeight 代表当前视口的高度\r\nimg.getBoundingClientRect().top < document.documentElement.clientHeight\r\n```\r\n\r\n**监听 `window.scroll` 事件也优化一下**\r\n\r\n加个节流器，提高性能。工作中一般使用 `lodash.throttle` 就可以了，万能的 `lodash` 啊！\r\n\r\n``` js\r\n_.throttle(func, [wait=0], [options={}])\r\n```\r\n\r\n参考 [什么是防抖和节流，他们的应用场景有哪些](https://github.com/shfshanyue/Daily-Question/issues/3)\r\n\r\n## 方案三\r\n\r\n再改进一下\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n**方案二使用的方法是: `window.scroll` 监听 `Element.getBoundingClientRect()` 并使用 `_.throttle` 节流**\r\n\r\n**一系列组合动作太复杂了，于是浏览器出了一个三合一事件: `IntersectionObserver` API，一个能够监听元素是否到了当前视口的事件，一步到位！**\r\n\r\n事件回调的参数是 [IntersectionObserverEntry](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry) 的集合，代表关于是否在可见视口的一系列值\r\n\r\n其中，`entry.isIntersecting` 代表目标元素可见\r\n\r\n``` javascript\r\nconst observer = new IntersectionObserver((changes) => {\r\n  // changes: 目标元素集合\r\n  changes.forEach((change) => {\r\n    // intersectionRatio\r\n    if (change.isIntersecting) {\r\n      const img = change.target\r\n      img.src = img.dataset.src\r\n      observer.unobserve(img)\r\n    }\r\n  })\r\n})\r\n\r\nobserver.observe(img)\r\n```\r\n\r\n**当然，`IntersectionObserver` 除了给图片做懒加载外，还可以对单页应用资源做预加载。**\r\n\r\n如在 `next.js v9` 中，会对视口内的资源做预加载，可以参考 [next 9 production optimizations](https://nextjs.org/blog/next-9#production-optimizations)\r\n\r\n``` jsx\r\n<Link href=\"/about\">\r\n  <a>关于山月</a>\r\n</Link>\r\n```\r\n\r\n## 方案四\r\n\r\n浏览器觉得懒加载这事可以交给自己做，你们开发者加个属性就好了。实在是...！\r\n\r\n``` html\r\n<img src=\"shanyue.jpg\" loading=\"lazy\">\r\n```\r\n\r\n不过目前浏览器兼容性不太好，关于 `loading` 属性的文章也可以查看 [Native image lazy-loading for the web!](https://addyosmani.com/blog/lazy-loading/)\r\n",
      "reactions": {
        "totalCount": 8
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY0MjgxNDI=",
    "number": 2,
    "title": "【Q002】当 ping 一个 IP 地址时发生了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTMzNjQ4Nw==",
      "body": "从 `ping` 的 `man` 手册就可以看出来，`ping` 实际上发送了 `ICMP ECHO_REQUEST` 的报文\r\n\r\n> ping -- send ICMP ECHO_REQUEST packets to network hosts\r\n\r\n通过让目标 IP 地址返回 `ICMP ECHO_RESPONSE` 报文来判断 IP 可不可达",
      "reactions": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTUzMjA=",
    "number": 3,
    "title": "【Q003】什么是防抖和节流，他们的应用场景有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1Mzg5OTIzNw==",
      "body": "## 防抖 (debounce)\r\n\r\n防抖，顾名思义，防止抖动，以免把一次事件误认为多次，敲键盘就是一个每天都会接触到的防抖操作。\r\n\r\n想要了解一个概念，必先了解概念所应用的场景。在 JS 这个世界中，有哪些防抖的场景呢\r\n\r\n1. 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖\r\n1. 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖\r\n1. 文本编辑器实时保存，当无任何更改操作一秒后进行保存\r\n\r\n代码如下，可以看出来**防抖重在清零 `clearTimeout(timer)`**\r\n\r\n``` js\r\nfunction debounce (f, wait) {\r\n  let timer\r\n  return (...args) => {\r\n    clearTimeout(timer)\r\n    timer = setTimeout(() => {\r\n      f(...args)\r\n    }, wait)\r\n  }\r\n}\r\n```\r\n\r\n## 节流 (throttle)\r\n\r\n节流，顾名思义，控制水的流量。控制事件发生的频率，如控制为1s发生一次，甚至1分钟发生一次。与服务端(server)及网关(gateway)控制的限流 (Rate Limit) 类似。\r\n\r\n1. `scroll` 事件，每隔一秒计算一次位置信息等\r\n1. 浏览器播放事件，每个一秒计算一次进度信息等\r\n1. input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖)\r\n\r\n代码如下，可以看出来**节流重在加锁 `timer=timeout`**\r\n\r\n``` js\r\nfunction throttle (f, wait) {\r\n  let timer\r\n  return (...args) => {\r\n    if (timer) { return }\r\n    timer = setTimeout(() => {\r\n      f(...args)\r\n      timer = null\r\n    }, wait)\r\n  }\r\n}\r\n```\r\n\r\n## 总结 (简要答案)\r\n\r\n+ 防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。**代码实现重在清零 `clearTimeout`**。防抖可以比作等电梯，只要有一个人进来，就需要再等一会儿。业务场景有避免登录按钮多次点击的重复提交。\r\n+ 节流：控制流量，单位时间内事件只能触发一次，与服务器端的限流 (Rate Limit) 类似。**代码实现重在开锁关锁 `timer=timeout; timer=null`**。节流可以比作过红绿灯，每等一个红灯时间就可以过一批。",
      "reactions": {
        "totalCount": 5
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTU2NzM=",
    "number": 4,
    "title": "【Q004】如何获取一个进程的内存并监控",
    "body": "在编写脚本时，有时会出现内存过大发生 OOM 的事情，那我们如何得知某个进程的内存？另外又如何监控它",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0MjE4MQ==",
      "body": "通过 `ps` 可以获知一个进程所占用的内存\r\n\r\n``` bash\r\n$ ps -O rss -p 3506\r\n  PID   RSS S TTY          TIME COMMAND\r\n 3506  6984 S pts/1    00:00:00 vim\r\n```\r\n\r\n如果要监控内存，肯定使用对进程万能的命令 `pidstat` （PS: 这名字一听就知道是干嘛的）\r\n\r\n``` bash\r\n# -r 显示内存信息\r\n# -p 指定 pid\r\n# 1: 每个一秒打印一次\r\n$ pidstat -r -p 3506 1\r\nLinux 3.10.0-957.21.3.el7.x86_64 (shanyue)      11/04/19        _x86_64_        (2 CPU)\r\n\r\n20:47:35      UID       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command\r\n20:47:36        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:37        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:38        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:39        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:40        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:41        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n```\r\n\r\n`pidstat` 是属于 `sysstat` 下的 linux 性能工具，但在 mac 中，如何定位内存的变化？此时可以使用万能的 `top/htop`\r\n\r\n ``` bash\r\n $ htop -p 31796\r\n ```\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/86353210-7b210080-bc99-11ea-9885-8e5ca1b909b5.png)\r\n\r\n## 总结\r\n\r\n简而言之，有以下三个命令\r\n\r\n1. `pidstat -r`\r\n1. `htop/top -p`\r\n1. `ps -O rss -p`\r\n\r\n关于更多指标的监控可以参考我的文章: [linux 各项监控指标小记](https://shanyue.tech/op/linux-monitor.html)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTY0NDM=",
    "number": 6,
    "title": "【Q005】生产环境的某个接口报错，如何定位",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0NTU1Ng==",
      "body": "1. 测试环境有没有问题，有问题可以在测试环境测试\r\n1. 有没有异常报警系统，如 `sentry`，如果有在 `sentry` 中查看堆栈信息以及相关上下文，定位代码\r\n1. 如果堆栈信息不足够找到问题，看有没有链路追踪工具，如 `zipkin`。从 `sentry` 中找到 `requestId`，在数据库日志/上下游链路日志中查找对应 `requestId` 的日志\r\n1. 查看接口相关代码 \r\n\r\n既然报错，那么一定会在异常上报系统中找到 `Issue` 进行定位。最怕的是那种接口没报错，但是业务方反馈数据有误的问题了，只能开了 debug，进行代码调试了",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5MjM2NzU=",
    "number": 7,
    "title": "【Q006】如何写一个 SQL 获取分组 top n 的数据",
    "body": "一个学校中的每个学生属于一个班级，如何获取每个班的前三名\r\n\r\n假设有学生表 `student(id, score, class_id)`，`score` 代表分数，`class_id` 代表班级，如何写出 SQL 取每个班级分数前三名",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTIzNDQxOQ==",
      "body": "通过一个自连接可以获取到\r\n\r\n``` sql\r\nselect id, class_id, score from student s1 where (\r\n  -- 对比每行 student，通过自连接找到该班中比该 student 分数要高与等于的人数，即排名\r\n  select count(*) from student s2 where s2.class_id = s1.class_id and s2.score >= s1.score\r\n) = 1\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5ODg0NTQ=",
    "number": 8,
    "title": "【Q007】如何写一个 SQL 获取分组 top 1 的数据 ",
    "body": "一个学校中的每个学生属于一个班级，如何获取每个班的前三名\r\n\r\n假设有学生表 `student(id, score, class_id)`，`score` 代表分数，`class_id` 代表班级，如何写出 SQL 取每个班级分数前一名\r\n\r\n与 [Top n](https://github.com/shfshanyue/Daily-Question/issues/7) 类似，不过有更简单的方法\r\n\r\n（当然考虑到并列情况就会复杂很多",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0MzI2OA==",
      "body": "单纯的获取 Top 1，只需要 `group by` 加聚合函数，不过复杂的还是参考 [top n](https://github.com/shfshanyue/Daily-Question/issues/7)\r\n\r\n``` sql\r\nselect class_id, max(score) from student group by class_id\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5OTQ0NTk=",
    "number": 9,
    "title": "【Q008】当新入职一家公司时，如何快速搭建开发环境并让应用跑起来",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU0OTM1MTAyOA==",
      "body": "这要看这家公司的基础设施怎么样了（当然面试时，最好在反问面试官环节问问这个问题）\r\n\r\n+ 查看是否有 `dockerfile`，如果有跟着 `dockerfile` 跑命令\r\n+ 查看是否有 `CI/CD`，如果有跟着 `CI/CD` 部署的脚本跑命令\r\n\r\n如果都没有，那只能到处问人自求多福了\r\n\r\n不过鉴于本地环境与开发环境部署的有可能不同（特别是前端，开发时需要起个 server），也有几个点需要注意\r\n\r\n1. 前端有可能在本地环境启动时需要依赖前端部署时所产生的文件，所以有时需要先正常部署一遍，再试着按照本地环境启动 (即需要先 `npm run build` 一下，再 `npm run dev`)\r\n1. 别忘了设置环境变量",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc1ODAwMTc=",
    "number": 10,
    "title": "【Q009】如何实现一个元素的水平垂直居中",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MTM1MTM2Nw==",
      "body": "提供一个较少提过的方法，使用 `grid`，它是做二维布局的，但是只有一个子元素时，一维布局与二维布局就一样了。结合 `justify-content`/`justify-items` 和 `align-content/align-items` 就有四种方案\r\n\r\n效果可以见 [codepen](https://codepen.io/shanyue/pen/ZEERzzL)\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-content: center;\r\n  align-content: center;\r\n}\r\n```\r\n\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n```\r\n\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-items: center;\r\n  align-content: center;\r\n}\r\n```\r\n\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-items: center;\r\n  align-items: center;\r\n}\r\n```\r\n",
      "reactions": {
        "totalCount": 5
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc2MTA0MTY=",
    "number": 11,
    "title": "【Q010】了解 React 中的 ErrorBoundary 吗，它有那些使用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTAxODI3NQ==",
      "body": "错误不抛出，交给catch处理，然鹅并不能预先知道错误类型。。。",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "baihech",
        "url": "https://github.com/baihech"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc2MTIxNTM=",
    "number": 12,
    "title": "【Q011】vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDM3MTk0OQ==",
      "body": "简单描述就是: 性能更好，解决无法监听数组变化问题",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "xiaoai7904",
        "url": "https://github.com/xiaoai7904"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxODk2MDQ=",
    "number": 13,
    "title": "【Q012】helm v3 中为什么要弃用 tiller",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc3NjMxNA==",
      "body": "`helm` v2 中，`helm client` 通过 gRPC 把 `Chart` 交给 `tiller`。`tiller` 是 k8s 中的一个 `pod`，在 `k8s` 集群中根据 `Chart` 以及配置信息部署资源，架构图如下\r\n\r\n![https://supergiant.io/wp-content/uploads/2018/11/helm-workflow-new.jpg](https://supergiant.io/wp-content/uploads/2018/11/helm-workflow-new.jpg)\r\n\r\n这有一个问题，`tiller` 有一个最高权限的 RBAC，而运维，开发众多权限不同的人都可以通过 `tiller` 这个最高权限来部署新的应用，会产生相应的安全问题。\r\n\r\n于是，`helm v3` 去掉了 `tiller`，它的权限控制基于操作人员的 `kubeconfig`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxOTIzNTg=",
    "number": 14,
    "title": "【Q013】有没有使用过 react hooks，它带来了那些便利",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODI0NDg1NA==",
      "body": "依我的看法，`React hooks` 主要解决了状态以及副作用难以复用的场景，除此之外，他对我最大的好处就是在 `Console` 中不会看到重重叠叠相同名字的组件了(HOC)。\r\n\r\n目前使用感觉最爽的两个hook，都是关于请求的。一个是 `apollo-client` 的 `useQuery`，一个是 [swr](https://github.com/zeit/swr)。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxOTU3NDc=",
    "number": 15,
    "title": "【Q014】如何使用 react hooks 实现一个计数器的组件",
    "body": "如何使用 react hooks 实现最简单一个计数器的组件\r\n\r\n为了保证最最简单化，不需要暂停与开始状态",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODk2MjY4Mg==",
      "body": "```js\r\nimport React, { useEffect, useState } from \"react\";\r\n\r\nfunction App() {\r\n    const [count, setCount] = useState(0);\r\n    useEffect(() => {\r\n        const timer = setInterval(() => {\r\n            setCount(count => count + 1)\r\n        }, 1000)\r\n\r\n        return () => {\r\n           clearInterval(timer)\r\n        }\r\n    }, [])\r\n\r\n    return <h1>{count}</h1>\r\n}\r\n```",
      "reactions": {
        "totalCount": 15
      },
      "author": {
        "login": "mexyx",
        "url": "https://github.com/mexyx"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTkxNjI4Nzg=",
    "number": 16,
    "title": "【Q015】你们的前端项目是如何在线上部署的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MTA3MDkyMA==",
      "body": "> 今天正好写了一篇长文来回答这个问题\r\n\r\n前端一说起刀耕火种，那肯定紧随着前端工程化这一话题。随着 `react`/`vue`/`angular`，`es6+`，`webpack`，`babel`，`typescript` 以及 `node` 的发展，前端已经在逐渐替代过去 script 引 cdn 开发的方式了，掀起了工程化这一大浪潮。得益于工程化的发展与开源社区的良好生态，前端应用的可用性与效率得到了很大提高。\r\n\r\n前端以前是刀耕火种，那前端应用部署在以前也是刀耕火种。那前端应用部署的发展得益于什么，随前端工程化带来的副产品？\r\n\r\n这只是一部分，而更重要的原因是 `devops` 的崛起。\r\n\r\n为了更清晰地理解前端部署的发展史，了解部署时运维和前端（或者更广泛地说，业务开发人员）的职责划分，当每次前端部署发生改变时，可以思考两个问题\r\n\r\n1. 缓存，前端应用中http 的 `response header` 由谁来配？得益于工程化发展，可以对打包后得到带有 hash 值的文件可以做永久缓存\r\n1. 跨域，`/api` 的代理配置由谁来配？在开发环境前端可以开个小服务，启用 `webpack-dev-server` 配置跨域，那生产环境呢\r\n\r\n这两个问题都是前端面试时的高频问题，但话语权是否掌握在前端手里\r\n\r\n时间来到 `React` 刚刚发展起来的这一年，这时已经使用 `React` 开发应用，使用 `webpack` 来打包。但是前端部署，仍是刀耕火种\r\n\r\n## 刀耕火种\r\n\r\n一台跳板机\r\n\r\n一台生产环境服务器\r\n\r\n一份部署脚本\r\n\r\n前端调着他的 `webpack`，开心地给运维发了部署邮件并附了一份部署脚本，想着第一次不用套后端的模板，第一次前端可以独立部署。想着自己基础盘进一步扩大，前端不禁开心地笑了\r\n\r\n运维照着着前端发过来的部署邮件，一遍又一遍地拉着代码，改着配置，写着 `try_files`， 配着 `proxy_pass`。\r\n\r\n这时候，前端静态文件由 `nginx` 托管，`nginx` 配置文件大致长这个样子\r\n\r\n``` conf\r\nserver {\r\n  listen 80;\r\n  server_name shanyue.tech; \r\n\r\n  location / {\r\n    # 避免非root路径404\r\n    try_files $uri $uri/ /index.html;\r\n  }\r\n\r\n  # 解决跨域\r\n  location /api {\r\n    proxy_pass http://api.shanyue.tech;\r\n  }\r\n\r\n  # 为带 hash 值的文件配置永久缓存\r\n  location ~* \\.(?:css|js)$ {\r\n      try_files $uri =404;\r\n      expires 1y;\r\n      add_header Cache-Control \"public\";\r\n  }\r\n\r\n  location ~ ^.+\\..+$ {\r\n      try_files $uri =404;\r\n  }\r\n}\r\n```\r\n\r\n不过...经常有时候跑不起来\r\n\r\n运维抱怨着前端的部署脚本没有标好 `node` 版本，前端嚷嚷着测试环境没问题\r\n\r\n这个时候运维需要费很多心力放在部署上，甚至测试环境的部署上，前端也要操心放在运维如何部署上。这个时候由于怕影响线上环境，上线往往选择在深夜，前端和运维身心俱疲\r\n\r\n不过向来如此\r\n\r\n鲁迅说，向来如此，那便对么。\r\n\r\n**这个时候，无论跨域的配置还是缓存的配置，都是运维来管理，运维不懂前端。但配置方式却是前端在提供，而前端并不熟悉 nginx**\r\n\r\n## 使用 docker 构建镜像\r\n\r\n`docker` 的引进，很大程度地解决了部署脚本跑不了这个大BUG。**`dockerfile` 即部署脚本，部署脚本即 `dockerfile`**。也很大程度缓解了前端运维的摩擦，毕竟前端越来越靠谱了，至少部署脚本没有问题了 (笑\r\n\r\n这时候，前端不再提供静态资源，而是提供服务，一个 `http` 服务\r\n\r\n前端写的 `dockerfile` 大致长这个样子\r\n\r\n``` dockerfile\r\nFROM node:alpine\r\n\r\n# 代表生产环境\r\nENV PROJECT_ENV production\r\n# 许多 package 会根据此环境变量，做出不同的行为\r\n# 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打包时会写死该环境变量\r\nENV NODE_ENV production\r\nWORKDIR /code\r\nADD . /code\r\nRUN npm install && npm run build && npm install -g http-server\r\nEXPOSE 80\r\n\r\nCMD http-server ./public -p 80\r\n```\r\n\r\n单单有 `dockerfile` 也跑不起来，另外前端也开始维护一个 `docker-compose.yaml`，交给运维执行命令 `docker-compose up -d` 启动前端应用。前端第一次写 `dockerfile` 与 `docker-compose.yaml`，在部署流程中扮演的角色越来越重要。想着自己基础盘进一步扩大，前端不禁开心地笑了\r\n\r\n``` yaml\r\nversion: \"3\"\r\nservices:\r\n  shici:\r\n    build: .\r\n    expose:\r\n      - 80\r\n```\r\n\r\n\r\n运维的 `nginx` 配置文件大致长这个样子\r\n\r\n``` conf\r\nserver {\r\n  listen 80;\r\n  server_name shanyue.tech; \r\n\r\n  location / {\r\n    proxy_pass http://static.shanyue.tech;\r\n  }\r\n\r\n  location /api {\r\n    proxy_pass http://api.shanyue.tech;\r\n  }\r\n}\r\n```\r\n\r\n运维除了配置 `nginx` 之外，还要执行一个命令: `docker-compose up -d`\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，由于从静态文件转换为服务，缓存开始交由前端控制 (但是镜像中的 `http-server` 不太适合做这件事情)\r\n1. 跨域，跨域仍由运维在 `nginx` 中配置\r\n\r\n前端可以做他应该做的事情中的一部分了，这是一件令人开心的事情\r\n\r\n当然，前端对于 `dockerfile` 的改进也是一个慢慢演进的过程，那这个时候镜像有什么问题呢？\r\n\r\n1. 构建镜像体积过大\r\n1. 构建镜像时间过长\r\n\r\n## 使用多阶段构建优化镜像\r\n\r\n这中间其实经历了不少坎坷，其中过程如何，详见我的另一篇文章: [如何使用 docker 部署前端应用](https://juejin.im/post/5c83cbaa6fb9a04a0f65fdaa)。\r\n\r\n其中主要的优化也是在上述所提到的两个方面\r\n\r\n1. 构建镜像体积由 1G+ 变为 10M+\r\n1. 构建镜像时间由 5min+ 变为 1min (视项目复杂程度，大部分时间在构建时间与上传静态资源时间)\r\n\r\n``` dockerfile\r\nFROM node:alpine as builder\r\n\r\nENV PROJECT_ENV production\r\nENV NODE_ENV production\r\n\r\nWORKDIR /code\r\n\r\nADD package.json /code\r\nRUN npm install --production\r\n\r\nADD . /code\r\n\r\n# npm run uploadCdn 是把静态资源上传至 oss 上的脚本文件，将来会使用 cdn 对 oss 加速\r\nRUN npm run build && npm run uploadCdn\r\n\r\n# 选择更小体积的基础镜像\r\nFROM nginx:alpine\r\nCOPY --from=builder code/public/index.html code/public/favicon.ico /usr/share/nginx/html/\r\nCOPY --from=builder code/public/static /usr/share/nginx/html/static\r\n```\r\n\r\n那它怎么做的\r\n\r\n1. 先 `ADD package.json /code`, 再 `npm install --production` 之后 `Add` 所有文件。充分利用镜像缓存，减少构建时间\r\n1. 多阶段构建，大大减小镜像体积\r\n\r\n另外还可以有一些小优化，如\r\n\r\n+ `npm cache` 的基础镜像或者 `npm` 私有仓库，减少 `npm install` 时间，减小构建时间\r\n+ `npm install --production` 只装必要的包\r\n\r\n前端看着自己优化的 `dockerfile`，想着前几天还被运维吵，说什么磁盘一半的空间都被前端的镜像给占了，想着自己节省了前端镜像几个数量级的体积，为公司好像省了不少服务器的开销，想着自己的基础盘进一步扩大，不禁开心的笑了\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制，缓存在oss上设置，将会使用 cdn 对 oss 加速。此时缓存由前端写脚本控制\r\n1. 跨域，跨域仍由运维在 `nginx` 中配置\r\n\r\n## CI/CD 与 gitlab\r\n\r\n此时前端成就感爆棚，运维呢？运维还在一遍一遍地上线，重复着一遍又一遍的部署三个动作\r\n\r\n1. 拉代码\r\n1. `docker-compose up -d`\r\n1. 重启 nginx\r\n\r\n运维觉得再也不能这么下去了，于是他引进了 `CI`: 与现有代码仓库 `gitlab` 配套的 `gitlab ci`\r\n\r\n+ `CI`，`Continuous Integration`，持续集成\r\n+ `CD`，`Continuous Delivery`，持续交付\r\n\r\n重要的不是 `CI/CD` 是什么，重要的是现在运维不用跟着业务上线走了，不需要一直盯着前端部署了。这些都是 `CI/CD` 的事情了，它被用来做自动化部署。上述提到的三件事交给了 `CI/CD`\r\n\r\n`.gitlab-ci.yml` 是 `gitlab` 的 CI 配置文件，它大概长这个样子\r\n\r\n``` yaml\r\ndeploy:\r\n  stage: deploy\r\n  only:\r\n    - master\r\n  script:\r\n    - docker-compose up --build -d\r\n  tags:\r\n    - shell\r\n```\r\n\r\n`CI/CD` 不仅仅更解放了业务项目的部署，也在交付之前大大加强了业务代码的质量，它可以用来 `lint`，`test`，`package` 安全检查，甚至多特性多环境部署，我将会在我以后的文章将这部分事情\r\n\r\n我的一个服务器渲染项目 [shfshanyue/shici](https://github.com/shfshanyue/shici) 以前在我的服务器中就是以 `docker`/`docker-compose/gitlab-ci` 的方式部署，有兴趣的可以看看它的配置文件\r\n\r\n+ [shfshanyue/shici:Dockerfile](https://github.com/shfshanyue/shici/blob/master/Dockerfile)\r\n+ [shfshanyue/shici:docker-compose.yml](https://github.com/shfshanyue/shici/blob/master/docker-compose.yml)\r\n+ [shfshanyue/shici:gitlab-ci.yml](https://github.com/shfshanyue/shici/blob/master/.gitlab-ci.yml)\r\n\r\n如果你有个人服务器的话，也建议你做一个自己感兴趣的前端应用和配套的后端接口服务，并且配套 `CI/CD` 把它部署在自己的自己服务器上\r\n\r\n而你如果希望结合 `github` 做 `CI/CD`，那可以试一试 `github` + `github action`\r\n\r\n另外，也可以试试 `drone.ci`，如何部署可以参考我以前的文章: [github 上持续集成方案 drone 的简介及部署](https://juejin.im/post/5dc0b563f265da4cef190b8a)\r\n\r\n## 使用 kubernetes 部署\r\n\r\n随着业务越来越大，镜像越来越多，`docker-compose` 已经不太能应付，`kubernetes` 应时而出。这时服务器也从1台变成了多台，多台服务器就会有分布式问题\r\n\r\n**一门新技术的出现，在解决以前问题的同时也会引进复杂性。**\r\n\r\nk8s 部署的好处很明显: 健康检查，滚动升级，弹性扩容，快速回滚，资源限制，完善的监控等等\r\n\r\n那现在遇到的新问题是什么？\r\n\r\n**构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！**\r\n\r\n需要一个私有的镜像仓库，这是运维的事情，`harbor` 很快就被运维搭建好了，但是对于前端部署来说，复杂性又提高了\r\n\r\n先来看看以前的流程:\r\n\r\n1. 前端配置 `dockerfile` 与 `docker-compose`\r\n1. 生产环境服务器的 `CI runner` 拉代码(可以看做以前的运维)，`docker-compose up -d` 启动服务。然后再重启 `nginx`，做反向代理，对外提供服务\r\n\r\n以前的流程有一个问题: **构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！**，所以需要一个私有的镜像仓库，一个能够访问 `k8s` 集群的持续集成服务器\r\n\r\n流程改进之后结合 `k8s` 的流程如下\r\n\r\n1. 前端配置 `dockerfile`，构建镜像，推到镜像仓库\r\n1. 运维为前端应用配置 `k8s` 的资源配置文件，`kubectl apply -f` 时会重新拉取镜像，部署资源\r\n\r\n运维问前端，需不需要再扩大下你的基础盘，写一写前端的 `k8s` 资源配置文件，并且列了几篇文章\r\n\r\n+ [使用 k8s 部署你的第一个应用: Pod，Deployment 与 Service](https://juejin.im/post/5db8c2b46fb9a020256692dc)\r\n+ [使用 k8s 为你的应用配置域名: Ingress](https://juejin.im/post/5db8da4b6fb9a0204520b310)\r\n+ [使用 k8s 为你的域名加上 https](https://juejin.im/post/5db8d94be51d4529f73e2833)\r\n\r\n前端看了看后端十几个 k8s 配置文件之后，摇摇头说算了算了\r\n\r\n这个时候，`gitlab-ci.yaml` 差不多长这个样子，配置文件的权限由运维一人管理\r\n\r\n``` yaml\r\ndeploy:\r\n  stage: deploy\r\n  only:\r\n    - master\r\n  script:\r\n    - docker build -t harbor.shanyue.tech/fe/shanyue\r\n    - docker push harbor.shanyue.tech/fe/shanyue\r\n    - kubectl apply -f https://k8s-config.default.svc.cluster.local/shanyue.yaml\r\n  tags:\r\n    - shell\r\n```\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制\r\n1. 跨域，跨域仍由运维控制，在后端 `k8s` 资源的配置文件中控制 `Ingress`\r\n\r\n## 使用 helm 部署\r\n\r\n这时前端与运维已不太往来，除了偶尔新起项目需要运维帮个忙以外\r\n\r\n但好景不长，突然有一天，前端发现自己连个环境变量都没法传！于是经常找运维修改配置文件，运维也不胜其烦\r\n\r\n于是有了 `helm`，如果用一句话解释它，那它就是一个带有模板功能的 `k8s` 资源配置文件。作为前端，你只需要填参数。更多详细的内容可以参考我以前的文章 [使用 helm 部署 k8s 资源](https://juejin.im/post/5dbf7909f265da4d4b5fe7b4)\r\n\r\n假如我们使用 [bitnami/nginx](https://hub.helm.sh/charts/bitnami/nginx) 作为 `helm chart`，前端可能写的配置文件长这个样子\r\n\r\n``` yaml\r\nimage:\r\n  registry: harbor.shanyue.tech\r\n  repository: fe/shanyue\r\n  tag: 8a9ac0\r\n\r\ningress:\r\n  enabled: true\r\n  hosts:\r\n  - name: shanyue.tech\r\n    path: /\r\n\r\n  tls:\r\n  - hosts:\r\n      - shanyue.tech\r\n    secretName: shanyue-tls\r\n\r\n    # livenessProbe:\r\n    #   httpGet:\r\n    #     path: /\r\n    #     port: http\r\n    #   initialDelaySeconds: 30\r\n    #   timeoutSeconds: 5\r\n    #   failureThreshold: 6\r\n    # \r\n    # readinessProbe:\r\n    #   httpGet:\r\n    #     path: /\r\n    #     port: http\r\n    #   initialDelaySeconds: 5\r\n    #   timeoutSeconds: 3\r\n    #   periodSeconds: 5\r\n```\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制\r\n1. 跨域，跨域由后端控制，配置在后端 Chart 的配置文件 `values.yaml` 中\r\n\r\n到了这时前端和运维的职责所在呢？\r\n\r\n前端需要做的事情有:\r\n\r\n1. 写前端构建的 `dockerfile`，这只是一次性的工作，而且有了参考\r\n1. 使用 `helm` 部署时指定参数\r\n\r\n那运维要做的事情呢\r\n\r\n1. 提供一个供所有前端项目使用的 `helm chart`，甚至不用提供，如果运维比较懒那就就使用 [bitnami/nginx](https://hub.helm.sh/charts/bitnami/nginx) 吧。也是一次性工作\r\n1. 提供一个基于 `helm` 的工具，禁止业务过多的权限，甚至不用提供，如果运维比较懒那就直接使用 `helm`\r\n\r\n这时前端可以关注于自己的业务，运维可以关注于自己的云原生，职责划分从未这般清楚\r\n\r\n## 统一前端部署平台\r\n\r\n后来运维觉得前端应用的本质是一堆静态文件，较为单一，容易统一化，来避免各个前端镜像质量的参差不齐。于是运维准备了一个统一的 `node` 基础镜像\r\n\r\n前端再也不需要构建镜像，上传 CDN 了，他只需要写一份配置文件就可以了，大致长这个样子\r\n\r\n``` yaml\r\nbuild:\r\n  command: npm run build\r\n  dist: /dist\r\n\r\nhosts:\r\n- name: shanyue.tech\r\n  path: /\r\n\r\nheaders:\r\n- location: /*\r\n  values:\r\n  - cache-control: max-age=7200\r\n- location: assets/*\r\n  values:\r\n  - cache-control: max-age=31536000\r\n\r\nredirects:\r\n- from : /api\r\n  to: https://api.shanyue.tech\r\n  status: 200\r\n```\r\n\r\n此时，前端只需要写一份配置文件，就可以配置缓存，配置 `proxy`，做应该属于前端做的一切，而运维也再也不需要操心前端部署的事情了\r\n\r\n前端看着自己刚刚写好的配置文件，怅然若失的样子...\r\n\r\n不过一般只有大厂会有这么完善的前端部署平台，如果你对它有兴趣，你可以尝试下 `netlify`，可以参考我的文章: [使用 netlify 部署你的前端应用](https://shanyue.tech/op/deploy-fe-with-netlify.html)\r\n\r\n## 服务端渲染与后端部署\r\n\r\n大部分前端应用本质上是静态资源，剩下的少部分就是服务端渲染了，服务端渲染的本质上是一个后端服务，它的部署可以视为后端部署\r\n\r\n后端部署的情况更为复杂，比如\r\n\r\n1. 配置服务，后端需要访问敏感数据，但又不能把敏感数据放在代码仓库。你可以在 `environment variables`， `consul` 或者 `k8s configmap` 中维护\r\n1. 上下链路服务，你需要依赖数据库，上游服务\r\n1. 访问控制，限制 IP，黑白名单\r\n1. RateLimit\r\n1. 等等\r\n\r\n我将在以后的文章分享如何在 k8s 中部署一个后端\r\n\r\n## 小结\r\n\r\n随着 `devops` 的发展，前端部署越来越简单，可控性也越来越高，建议所有人都稍微学习一下 `devops` 的东西。\r\n\r\n道阻且长，行则将至。\r\n\r\n## 相关文章\r\n\r\n+ [个人服务器运维指南](https://juejin.im/post/5db7a9e2f265da4cf85d6fb9)\r\n+ [如果你想搭建一个博客](https://juejin.im/post/5db78500f265da4d0a68cef7)\r\n+ [当我有一台服务器时我做了什么](https://juejin.im/post/5c9232a8e51d45729b3b71e1)\r\n+ [使用 k8s 部署你的第一个应用: Pod，Deployment 与 Service](https://juejin.im/post/5db8c2b46fb9a020256692dc)\r\n+ [使用 k8s 为你的应用配置域名: Ingress](https://juejin.im/post/5db8da4b6fb9a0204520b310)\r\n+ [使用 k8s 为你的域名加上 https](https://juejin.im/post/5db8d94be51d4529f73e2833)\r\n",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk1OTg4MDg=",
    "number": 17,
    "title": "【Q016】后端的敏感数据在生产环境是如何配置的",
    "body": "后端的敏感数据在生产环境是如何配置的，如数据库的账号密码，jwt 的 secret，联调上游服务的 token 等",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MTM0NjI1OA==",
      "body": "目前我们的方式是在每次部署之前，在 [vault](https://github.com/hashicorp/vault) 和 [consul](https://github.com/hashicorp/consul) 拉取敏感数据，写在配置文件中\r\n\r\n另外，还有几种可选的方案\r\n\r\n1. 跟随 `CI/CD` 的环境变量，敏感配置放在 CI 平台\r\n1. 跟随 k8s `secret`/`configMap`，敏感配置放在 k8s 集群\r\n1. 跟随专有的配置服务，如 `consul`/`vault`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk5NTY3NjQ=",
    "number": 18,
    "title": "【Q017】css 如何实现左侧固定300px，右侧自适应的布局",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODY1NTA5NQ==",
      "body": "使用 `flex` 布局，左侧 `300px`，右侧 `flex-grow: 1`。`pug` 代码及 `css` 代码示例如下\r\n\r\n``` pug\r\n.container\r\n  .left\r\n  .main\r\n```\r\n\r\n``` css\r\n.container {\r\n  display: flex;\r\n}\r\n\r\n.left {\r\n  flex-basis: 300px;\r\n}\r\n\r\n.main {\r\n  flex-grow: 1;\r\n}\r\n```\r\n\r\n此处看起来比较圆满了，其实还有一个缺陷: **如果 .main 区域过大挤压 .left 区域怎么办**，此时还需要加一个禁止挤压\r\n\r\n``` css\r\n.left {\r\n  flex-basis: 300px;\r\n  flex-shrink: 0;\r\n}\r\n```\r\n\r\n## 总结\r\n\r\n使用 `flex` 进行如下布局\r\n\r\n``` pug\r\n.container\r\n  .left\r\n  .main\r\n```\r\n\r\n``` css\r\n.container {\r\n  display: flex;\r\n}\r\n\r\n.left {\r\n  flex-basis: 300px;\r\n  flex-shrink: 0;\r\n}\r\n\r\n.main {\r\n  flex-grow: 1;\r\n}\r\n```",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk5NTk0MTI=",
    "number": 19,
    "title": "【Q018】当你使用 docker 部署应用时，如何查看应用日志",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MjQ0MjU4NA==",
      "body": "在docker中使用 `docker logs CONTAINER`\r\n\r\n如果在k8s中使用 `kubectl logs POD`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA0MjExNDI=",
    "number": 20,
    "title": "【Q019】如何实现选中复制的功能",
    "body": "在一些博客系统，如掘金的博客中，可以复制代码，它是如何实现的",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MjA5OTE2NQ==",
      "body": "它一般可以使用第三方库 [clipboard.js](https://github.com/zenorocha/clipboard.js) 来实现，源码很简单，可以读一读\r\n\r\n主要有两个要点\r\n\r\n1. 选中: `Selection API`\r\n1. 复制: `document.execCommand`\r\n\r\n## 选中\r\n\r\n选中主要利用了 [Selection API](https://developer.mozilla.org/en-US/docs/Web/API/Selection)\r\n\r\n选中的代码如下\r\n\r\n``` js\r\nconst selection = window.getSelection();\r\nconst range = document.createRange();\r\n\r\nrange.selectNodeContents(element);\r\nselection.removeAllRanges();\r\nselection.addRange(range);\r\n\r\nselectedText = selection.toString();\r\n```\r\n\r\n取消选中的代码如下\r\n\r\n``` js\r\nwindow.getSelection().removeAllRanges();\r\n```\r\n\r\n它有现成的第三方库可以使用: [select.js](https://github.com/zenorocha/select)\r\n\r\n## 复制\r\n\r\n复制就比较简单了，`execCommand`\r\n\r\n``` js\r\ndocument.exec('copy')\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA0Mjc1NzU=",
    "number": 21,
    "title": "【Q020】如何实现一个分布式锁",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc2NTk0NA==",
      "body": "mysql,redis,zk redis效率较高\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "zhangxiaokun",
        "url": "https://github.com/zhangxiaokun"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjU4MDk=",
    "number": 22,
    "title": "【Q021】React 中，cloneElement 与 createElement 各是什么，有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDY4ODc0MQ==",
      "body": "``` js\r\nReact.cloneElement(\r\n  element,\r\n  [props],\r\n  [...children]\r\n)\r\n\r\nReact.createElement(\r\n  type,\r\n  [props],\r\n  [...children]\r\n)\r\n```\r\n\r\n直接上 API，很容易得出结论：首参不一样。这也是他们的最大区别：\r\n\r\n1. `cloneElement`，根据 Element 生成新的 Element\r\n1.  `createElement`，根据 Type 生成新的 Element\r\n\r\n然而，此时估计还是云里雾里，含糊不清，需要弄清它，首先要明白俩概念\r\n\r\n1. Type\r\n1. Element\r\n\r\n## React.cloneElement 的使用场景",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjY4MzA=",
    "number": 23,
    "title": "【Q022】如何实现一个简单的 Promise",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjA0Mg==",
      "body": "一个简单的 `Promise` 的粗糙实现，关键点在于\r\n\r\n1. 当 `pending` 时， `thenable` 函数由一个队列维护\r\n1. 当状态变为 `resolved(fulfilled)` 时，队列中所有 `thenable` 函数执行\r\n1. 当 `resolved` 时， `thenable` 函数直接执行\r\n\r\n<!--more-->\r\n\r\n`rejected` 状态同理\r\n\r\n```javascript\r\nclass Prom {\r\n  static resolve (value) {\r\n    if (value && value.then) {\r\n      return value \r\n    }\r\n    return new Prom(resolve => resolve(value))\r\n  }\r\n\r\n  constructor (fn) {\r\n    this.value = undefined\r\n    this.reason = undefined\r\n    this.status = 'PENDING'\r\n\r\n    // 维护一个 resolve/pending 的函数队列\r\n    this.resolveFns = []\r\n    this.rejectFns = []\r\n\r\n    const resolve = (value) => {\r\n      // 注意此处的 setTimeout\r\n      setTimeout(() => {\r\n        this.status = 'RESOLVED'\r\n        this.value = value\r\n        this.resolveFns.forEach(({ fn, resolve: res, reject: rej }) => res(fn(value)))\r\n      })\r\n    }\r\n\r\n    const reject = (e) => {\r\n      setTimeout(() => {\r\n        this.status = 'REJECTED'\r\n        this.reason = e\r\n        this.rejectFns.forEach(({ fn, resolve: res, reject: rej }) => rej(fn(e)))\r\n      })\r\n    }\r\n\r\n    fn(resolve, reject)\r\n  }\r\n\r\n\r\n  then (fn) {\r\n    if (this.status === 'RESOLVED') {\r\n      const result = fn(this.value)\r\n      // 需要返回一个 Promise\r\n      // 如果状态为 resolved，直接执行\r\n      return Prom.resolve(result)\r\n    }\r\n    if (this.status === 'PENDING') {\r\n      // 也是返回一个 Promise\r\n      return new Prom((resolve, reject) => {\r\n        // 推进队列中，resolved 后统一执行\r\n        this.resolveFns.push({ fn, resolve, reject }) \r\n      })\r\n    }\r\n  }\r\n\r\n  catch (fn) {\r\n    if (this.status === 'REJECTED') {\r\n      const result = fn(this.value)\r\n      return Prom.resolve(result)\r\n    }\r\n    if (this.status === 'PENDING') {\r\n      return new Prom((resolve, reject) => {\r\n        this.rejectFns.push({ fn, resolve, reject }) \r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nProm.resolve(10).then(o => o * 10).then(o => o + 10).then(o => {\r\n  console.log(o)\r\n})\r\n\r\nreturn new Prom((resolve, reject) => reject('Error')).catch(e => {\r\n  console.log('Error', e)\r\n})\r\n```\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjY5ODI=",
    "number": 24,
    "title": "【Q023】websocket 服务多节点部署时会有什么问题，怎么解决",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4NzQ4MA==",
      "body": "## 多节点问题\r\n\r\n在开始思考分布式会有什么问题时，先来回答一个问题: 服务端如何与客户端交流？\r\n\r\n在 ws 服务端，当与客户端连接成功后，会生成一个对象 `connection`，ws 会维护一个与客户端所有连接的 `connections`。如果想要主动推送消息到客户端，只需要调用API `connection.sendText(message)`。\r\n\r\n那如何给所有人广播消息呢？\r\n\r\n服务器只需要与它自身的所有连接 `server.connections` 挨个发消息就是广播，所以它只是一个伪广播：我要给群里所有人发消息，但我不能在群里发，只能挨个私发。\r\n\r\n### 单节点\r\n\r\n当单节点时所有用户都能正常受到通知，流程如下\r\n\r\n![ws 单节点时](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-single-node.jpg)\r\n\r\n这时所有用户都能收到消息通知\r\n\r\n### 多节点\r\n\r\n当多节点时，就会有部分用户无法正常受到通知，从以下流程图中可以很清楚地看到问题所在\r\n\r\n![ws 多节点时](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-multi-node.jpg)\r\n\r\n**负载到节点2的所有用户都没有收到消息通知**\r\n\r\n## 如何解决\r\n\r\n多节点服务器就会有分布式问题，解决分布式问题就找一个大家都能找到的地，比如说 `Redis`，比如说 `Kafka` 等消息件\r\n\r\n改进后流程图如下\r\n\r\n1. 需要向所有用户推送消息，请求 websocket 服务\r\n1. 负载均衡到某个节点\r\n1. 该节点向 redis/kafka 推送消息: 向所有用户推送消息通知\r\n1. 所有节点在 redis/kafka 上订阅消息\r\n1. 订阅成功后所有节点向客户端 push 消息\r\n\r\n![借用 redis](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-redis.jpg)\r\n\r\n## redis PUBSUB\r\n\r\n其中有一个细节是 pub/sub 那里，redis 的 `pubsub` 较 `Kafka` 等消息中间件更为轻便，**最主要的是与ws集成的社区方案比较成熟，这点很重要**，如 Node 中的以下两个\r\n\r\n+ [graphql subscriptions - redis](https://github.com/davidyaha/graphql-redis-subscriptions)\r\n+ [socket.io-redis](https://github.com/socketio/socket.io-redis)\r\n\r\n`pubsub` 在 redis 中的命令如下\r\n\r\n+ pub: `publish channel message`\r\n+ sub: `subscribe`\r\n\r\n如果我们要订阅 `eat` 这个 `channel` 的话，图示如下\r\n\r\n![redis pubsub example](https://raw.githubusercontent.com/shfshanyue/Daily-Question/master/assets/pubsub.png)\r\n\r\n## 进一步追问\r\n\r\n面试官见我回答完问题后，又一次追问\r\n\r\n**那 websocket 如何向特定的用户组推送消息？**\r\n\r\n假如一个学校有以下数据结构\r\n\r\n1. `Class`: 代表班级\r\n1. `Student`: 代表学生，每个学生都在其中一个班级\r\n\r\n那假如要向 `Class:201901` 班级的所有学生发送通知，应该如何实现\r\n\r\n欢迎在 Issue 中讨论: [【Q029】websocket 如何向特定用户组推送消息](https://github.com/shfshanyue/Daily-Question/issues/30)\r\n\r\n## 小结\r\n\r\n借用解决方案的图作为小结\r\n\r\n![借用 redis](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-redis.jpg)\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA4MDYxMTU=",
    "number": 25,
    "title": "【Q024】在 postgres 中，查询时如何对 jsonb 数据格式化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MjM0MDU0Ng==",
      "body": "使用 `jsonb_pretty` 函数，示例如下\r\n\r\n``` sql\r\n> select jsonb_pretty('{\"a\": {\"b\": 4}}'::jsonb)\r\n+----------------+\r\n| jsonb_pretty   |\r\n|----------------|\r\n| {              |\r\n|     \"a\": {     |\r\n|         \"b\": 4 |\r\n|     }          |\r\n| }              |\r\n+----------------+\r\nSELECT 1\r\nTime: 0.018s\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA5NTU1MDI=",
    "number": 26,
    "title": "【Q025】简述 TCP socket 建立的过程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjMyNQ==",
      "body": "一图胜千言\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/68817970-5e11d000-06be-11ea-85ee-5d2496d14c63.png)\r\n",
      "reactions": {
        "totalCount": 3
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEyOTc0OTU=",
    "number": 27,
    "title": "【Q026】如何对接口进行压力测试",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjE0NQ==",
      "body": "``` bash\r\n$ ab\r\n\r\n$ wrk\r\n\r\n$ siege\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEzNzA0Mjg=",
    "number": 28,
    "title": "【Q027】在前端开发中，如何获取浏览器的唯一标识",
    "body": "如何获取浏览器的唯一标识，原理是什么",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc4NDQ1Ng==",
      "body": "由于不同的系统显卡绘制 `canvas` 时渲染参数、抗锯齿等算法不同，因此绘制成图片数据的 `CRC` 校验也不一样。\r\n\r\n``` js\r\nfunction getCanvasFp () {\r\n  const canvas = document.getElementById('canvas')\r\n  const ctx = canvas.getContext('2d')\r\n  ctx.font = '14px Arial'\r\n  ctx.fillStyle = '#ccc'\r\n  ctx.fillText('hello, shanyue', 2, 2)\r\n  return canvas.toDataURL('image/jpeg')\r\n}\r\n```\r\n\r\n因此根据 `canvas` 可以获取浏览器指纹信息。\r\n\r\n1. 绘制 `canvas`，获取 `base64` 的 dataurl\r\n1. 对 dataurl 这个字符串进行 `md5` 摘要计算，得到指纹信息\r\n\r\n但是对于常见的需求就有成熟的解决方案，若在生产环境使用，可以使用以下库\r\n\r\n+ [fingerprintjs2](https://github.com/Valve/fingerprintjs2)\r\n\r\n它依据以下信息，获取到浏览器指纹信息，**而这些信息，则成为 `component`**\r\n\r\n1. `canvas`\r\n1. `webgl`\r\n1. `UserAgent`\r\n1. `AudioContext`\r\n1. 对新式 API 的支持程度等\r\n\r\n``` js\r\nrequestIdleCallback(function () {\r\n  Fingerprint2.get((components) => {\r\n    const values = components.map((component) => component.value)\r\n    const fp = Fingerprint2.x64hash128(values.join(''), 31)\r\n  })\r\n})\r\n```\r\n\r\n在 `fingerprintjs2` 中，对于 `component` 也有分类\r\n\r\n+ [browser independent component](https://github.com/Valve/fingerprintjs2/wiki/Browser-independent-components)：有些 `component` 同一设备跨浏览器也可以得到相同的值，有些独立浏览器，得到不同的值\r\n+ [stable component](https://github.com/Valve/fingerprintjs2/wiki/Stable-components): 有些 `component` 刷新后值就会发生变化，称为不稳定组件\r\n\r\n在实际业务中，可根据业务选择合适的组件\r\n\r\n``` js\r\nconst options = {\r\n  excludes: {userAgent: true, language: true}\r\n}\r\n```\r\n\r\n## 简答\r\n\r\n根据 `canvas` 可以获取浏览器指纹信息\r\n\r\n1. 绘制 `canvas`，获取 `base64` 的 dataurl\r\n1. 对 dataurl 这个字符串进行 `md5` 摘要计算，得到指纹信息\r\n\r\n若在生产环境使用，可以使用 [fingerprintjs2](https://github.com/Valve/fingerprintjs2)，根据业务需求，如单设备是否可跨浏览器，以此选择合适的 `component`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEzOTk3ODA=",
    "number": 29,
    "title": "【Q028】在linux中如何获取登录的用户",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MTg2OQ==",
      "body": "``` bash\r\n$ who\r\n\r\n$ last\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjE5MjExMTQ=",
    "number": 30,
    "title": "【Q029】websocket 如何向特定的用户组推送消息",
    "body": "假如一个学校有以下数据结构\r\n\r\n1. `Class`: 代表班级\r\n1. `Student`: 代表学生，每个学生都在其中一个班级\r\n\r\n那假如要向 `Class:201901` 班级的所有学生发送通知，应该如何实现",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDYyNjQzOA==",
      "body": "在 `redis` 处维护一个对象，记录每个 group 所对应的 `connections`/`sockets`\r\n\r\n``` js\r\n{\r\n  'Class:201901': [student1Socket, student2Socket]\r\n}\r\n```\r\n\r\n当 client 刚连入 server 时，便加入某个特定的组，或者叫 room，比如 student01，刚开始连入 server，可能要加入 room：`Student:01`，`Class:201901`，`Group:10086`",
      "reactions": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjI2MDI3MTU=",
    "number": 31,
    "title": "【Q030】linux 中如何打印所有网络接口",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1Mzc0MjYyOA==",
      "body": "## ifconfig\r\n\r\n`ifconfig` 是最简单最常用，但是打印信息太多了\r\n\r\n``` bash\r\n$ ifconfig\r\ncni0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1450\r\n        inet 10.244.0.1  netmask 255.255.255.0  broadcast 0.0.0.0\r\n        ether 9e:f3:9e:47:9d:55  txqueuelen 1000  (Ethernet)\r\n        RX packets 14733665  bytes 1007493238 (960.8 MiB)\r\n        RX errors 0  dropped 0  overruns 0  frame 0\r\n        TX packets 15040396  bytes 4534954611 (4.2 GiB)\r\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\r\n\r\ndocker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500\r\n        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255\r\n        ether 02:42:09:fe:1d:e5  txqueuelen 0  (Ethernet)\r\n        RX packets 0  bytes 0 (0.0 B)\r\n        RX errors 0  dropped 0  overruns 0  frame 0\r\n        TX packets 0  bytes 0 (0.0 B)\r\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\r\n```\r\n\r\n## netstat\r\n\r\n`netstat` 与 `ip` 也挺好用，特别是它们还可以打印路由表\r\n\r\n``` bash\r\n$ netstat -i\r\nKernel Interface table\r\nIface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg\r\ncni0             1450 14733471      0      0 0      15040202      0      0      0 BMRU\r\ndocker0          1500        0      0      0 0             0      0      0      0 BMU\r\neth0             1500 42833038      0      0 0      40961577      0      0      0 BMRU\r\nflannel.1        1450  4761436      0      0 0       4091581      0      0      0 BMRU\r\nlo              65536 376447249      0      0 0      376447249      0      0      0 LRU\r\nveth2052e2d6     1450  7358995      0      0 0       7518642      0      0      0 BMRU\r\nveth3190806e     1450  7363232      0      0 0       7510100      0      0      0 BMRU\r\n```\r\n\r\n## ip\r\n\r\n``` bash\r\n$ ip link\r\n\r\n$ ip addr\r\n```\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTY3MTM=",
    "number": 32,
    "title": "【Q031】js 中如何实现 bind",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDYyNzg0NA==",
      "body": "**最简单的 `bind` 一行就可以实现，而在实际面试过程中也不会考察你太多的边界条件**\r\n\r\n``` js\r\nFunction.prototype.fakeBind = function(obj) {\r\n  return (...args) => this.apply(obj, args)\r\n}\r\n```\r\n\r\n测试一下\r\n\r\n``` js\r\nfunction f (arg) {\r\n  console.log(this.a, arg)\r\n}\r\n\r\n// output: 3, 4\r\nf.bind({ a: 3 })(4)\r\n\r\n// output: 3, 4\r\nf.fakeBind({ a: 3 })(4)\r\n```\r\n",
      "reactions": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTgxNDI=",
    "number": 33,
    "title": "【Q032】js 中什么是 softbind，如何实现",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTkyNDM=",
    "number": 34,
    "title": "【Q033】如何对接口进行限流",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDYzMDg2MQ==",
      "body": "一般采用漏桶算法：\r\n\r\n1. 漏桶初始为空\r\n1. API 调用是在往漏桶里注水\r\n1. 漏桶会以一定速率出水\r\n1. 水满时 API 拒绝调用\r\n\r\n![漏桶算法](https://d33wubrfki0l68.cloudfront.net/e737eb0be9176ca74d03344f082281154f90f12c/c0076/assets/img/leaky-bucket.f8cb8f08.png)\r\n\r\n可以使用 `redis` 的计数器实现\r\n\r\n1. 计数器初始为空\r\n1. API 调用计数器增加\r\n1. 给计数器设置过期时间，隔段时间清零，视为一定速率出水\r\n1. 计数器达到上限时，拒绝调用\r\n\r\n当然，这只是大致思路，这时会有两个问题要注意\r\n\r\n1. 最坏情况下的限流是额定限流速率的2倍\r\n1. 条件竞争问题\r\n\r\n不过实际实现时注意以下就好了（话说一般也是调用现成的三方库做限流...)，可以参考我以前的文章 <https://shanyue.tech/post/rate-limit/>",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4Mjg0NTU=",
    "number": 35,
    "title": "【Q034】如何实现一个 loading 动画",
    "body": "如何实现一个 loading 动画，可用 css 或 svg",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NDQ3MDkwMg==",
      "body": "## svg实现方案\r\n\r\n```xml\r\n<svg classname=\"loading\" viewbox=\"25 25 50 50\">\r\n  <circle cx=\"50\" cy=\"50\" r=\"25\" classname=\"path\" fill=\"none\" />\r\n</svg>\r\n```\r\n```css\r\n.loading {\r\n  width: 50px;\r\n  height: 50px;\r\n  animation: rotate 2s linear 0s infinite;\r\n}\r\n.path {\r\n  animation: dash 2s ease-in-out infinite;\r\n  stroke: #00b390;\r\n  stroke-width: 2;\r\n  stroke-dasharray: 90 150;\r\n  stroke-dashoffset: 0;\r\n  stroke-linecap: round;\r\n}\r\n\r\n@keyframes rotate {\r\n  from {\r\n    tranform: rotate(0deg);\r\n  } \r\n  to {\r\n    tranform: rotate(360deg);\r\n  }\r\n}\r\n\r\n@keyframes dash {\r\n  0% {\r\n    stroke-dasharray:  1 150;\r\n    stroke-dashoffset: 0;\r\n  } \r\n  50% {\r\n    stroke-dasharray: 90 150;\r\n    stroke-dashoffset: -40px;\r\n  }\r\n  100% {\r\n    stroke-dasharray: 90 150;\r\n    stroke-dashoffset: -120px;\r\n  }\r\n}\r\n```\r\n\r\n",
      "reactions": {
        "totalCount": 2
      },
      "author": {
        "login": "hellojackhui",
        "url": "https://github.com/hellojackhui"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4MjkxMDQ=",
    "number": 36,
    "title": "【Q035】http 常见的状态码有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxNzI5NjU1MA==",
      "body": "原文地址: <https://shanyue.tech/post/http-status.html>\r\n\r\n*   肯定会碰到: 101/200/301/302/304/400/404/502\r\n*   可能会碰到: 101/200/201/204/206/301/304/307/400/401/403/404/405/413/418/422/429/500/501/502/503/504\r\n\r\n101 Switch Protocol\r\n-------------------\r\n\r\n升级协议，如从 http 到 ws，此时需要反向代理支持，如 Nginx，在 Nginx 配置 websockt 如下:\r\n\r\n```\r\nlocation / {\r\n  proxy_http_version 1.1;\r\n  proxy_set_header Upgrade $http_upgrade;\r\n  proxy_set_header Connection  $connection_upgrade;\r\n}\r\n\r\n\r\n```\r\n\r\n示例:\r\n\r\n![101](https://shanyue.tech/assets/img/101.071b734b.png)\r\n\r\n200 Ok\r\n------\r\n\r\n表示资源请求成功，也是最常见到的状态码\r\n\r\n示例:\r\n\r\n```\r\n$ curl https://shanyue.tech --head\r\nHTTP/2 200\r\n\r\n\r\n```\r\n\r\n201 Created\r\n-----------\r\n\r\n资源创建成功，多用于 POST 请求\r\n\r\n204 No Content\r\n--------------\r\n\r\n响应不会返回 Body，一般由以下两种情况\r\n\r\n1.  与 Options/Delete 请求搭配\r\n2.  打点类\r\n\r\n示例一: 掘金为 Options 请求的状态码设置为 204\r\n\r\n![掘金为 Options 请求的状态码设置为 204](https://shanyue.tech/assets/img/204.5355a3b7.png)\r\n\r\n示例二: 知乎为 Delete 请求的状态码设置为 204，以下请求为取消关注\r\n\r\n![掘金为 Delete 请求的状态码设置为 204](https://shanyue.tech/assets/img/204-del.ee530dd7.png)\r\n\r\n示例三: 当你在知乎看段子时，不妨打开控制台，会发现一个是 204 的状态码\r\n\r\n```\r\n\r\ncurl 'https://www.zhihu.com/sc-profiler' \\\r\n  -H 'content-type: application/json' \\\r\n  --data-binary '[[\"i\",\"production.heifetz.main.desktop.v1.Collector.screen.1536_960.count\",1,1]]' \\\r\n  --compressed -vvv\r\n< HTTP/2 204\r\n< server: CLOUD ELB 1.0.0\r\n< date: Thu, 22 Oct 2020 07:46:30 GMT\r\n< content-type: text/html\r\n< vary: Accept-Encoding\r\n< x-backend-response: 0.002\r\n< cache-control: no-cache, no-store, must-revalidate, private, max-age=0\r\n\r\n\r\n```\r\n\r\n206 Partial Content\r\n-------------------\r\n\r\n当请求多媒体数据数据较大时，会进行分片传输。当你在B站观看视频，打开开发者工具，会发现许多 206 状态码以及响应头 Content-Range\r\n\r\n示例:\r\n\r\n![B站上的视频资源请求状态码为206](https://shanyue.tech/assets/img/206.94474e79.png)\r\n\r\n301 Moved Permanently\r\n---------------------\r\n\r\n永久重定向。http 转向 https时，有时会使用 301，如 B 站。\r\n\r\n```\r\n$ curl www.bilibili.com -vvv\r\n< HTTP/1.1 301 Moved Permanently\r\n< Server: Tengine\r\n< Date: Thu, 22 Oct 2020 08:04:59 GMT\r\n< Content-Type: text/html\r\n< Content-Length: 239\r\n< Connection: keep-alive\r\n< Location: https://www.bilibili.com/\r\n\r\n\r\n```\r\n\r\n302 Found\r\n---------\r\n\r\n暂时重定向。http 转向 https时，有时也会使用 302，如知乎\r\n\r\n```\r\n$ curl www.zhihu.com -vvv\r\n< HTTP/1.1 302 Found\r\n< Location: https://www.zhihu.com/\r\n< Content-Length: 0\r\n< X-NWS-LOG-UUID: 16068764905156850032\r\n< Connection: keep-alive\r\n< Server: Lego Server\r\n< Date: Thu, 22 Oct 2020 08:20:29 GMT\r\n< X-Cache-Lookup: Return Directly\r\n\r\n\r\n```\r\n\r\n304 Not Modified\r\n----------------\r\n\r\n资源已被缓存，与之相关的响应头部有：\r\n\r\n*   `ETag`\r\n*   `last-modified`/`if-modified-since`\r\n\r\n一般用作 `index.html` 等不带 hash 的资源，由于示例太多，这里就不举例了\r\n\r\n307 Temporary Redirect\r\n----------------------\r\n\r\n暂时重定向。也可作为 http 到 https 的重定向。还有一种用途用作 HSTS，当谷歌浏览器发现某 http 资源已被加入到 HSTS 列表，浏览器内部会通过 307 作重定向\r\n\r\n示例:\r\n\r\n![山月个人博客网站的 HSTS](https://shanyue.tech/assets/img/307-shanyue.5f2e9bb3.png)\r\n\r\n![Stackoverflow 中的307](https://shanyue.tech/assets/img/307-stack.914347b0.png)\r\n\r\n> [http 状态码中 301，302和307有什么区别](https://github.com/shfshanyue/Daily-Question/issues/37)\r\n\r\n*   301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。\r\n*   302，Found。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307\r\n*   307，Temporary Redirect。临时重定向，在重定向时不会改变 method\r\n\r\n400 Bad Request\r\n---------------\r\n\r\n对于服务器无法理解的参数，将会使用 400 作为返回码\r\n\r\n示例一: 当 Content-Type: JSON 时，服务器解析 JSON 却失败\r\n\r\n```\r\nHTTP/1.1 400 Bad Request\r\nContent-Length: 35\r\n\r\n{\"message\":\"Problems parsing JSON\"}\r\n\r\n\r\n```\r\n\r\n401 Unauthorized\r\n----------------\r\n\r\n当没有权限的用户请求需要带有权限的资源时，会返回 401，此时携带正确的权限凭证再试一次可以解决问题\r\n\r\n有时认证失败也会返回 401\r\n\r\n示例一: 知乎登录时密码不正确\r\n\r\n![知乎登录失败时](https://shanyue.tech/assets/img/401.bd2d099f.png)\r\n\r\n示例二: Github中错误的凭证信息请求带权限资源\r\n\r\n```\r\n$ curl -i https://api.github.com -u foo:bar\r\n> HTTP/1.1 401 Unauthorized\r\n\r\n> {\r\n>   \"message\": \"Bad credentials\",\r\n>   \"documentation_url\": \"https://developer.github.com/v3\"\r\n> }\r\n\r\n\r\n```\r\n\r\n403 Forbidden\r\n-------------\r\n\r\n我就是不想让你访问，不管你的权限凭证是否正确！\r\n\r\n> In summary, a 401 Unauthorized response should be used for missing or bad authentication, and a 403 Forbidden response should be used afterwards, when the user is authenticated but isn’t authorized to perform the requested operation on the given resource.\r\n\r\n*   [403与401状态码有什么区别](https://stackoverflow.com/questions/3297048/403-forbidden-vs-401-unauthorized-http-responses)\r\n\r\n404 Not Found\r\n-------------\r\n\r\n未找到资源\r\n\r\n405 Method Not Allowed\r\n----------------------\r\n\r\n我需要 POST 这条资源，你去 GET 个锤子\r\n\r\n413 Payload Too Large\r\n---------------------\r\n\r\n不要给我扔这么大的 Body，我处理不过来\r\n\r\n418 I'm A Teapot\r\n----------------\r\n\r\n我是一个茶壶\r\n\r\n我要抛咖啡，你却扔给我一个茶壶？\r\n\r\n也可以用来处理不合法的参数校验，我想要个字符串，你给了我一个整数？\r\n\r\n422 Unprocessable Entity\r\n------------------------\r\n\r\n常用来处理不合法的参数校验。\r\n\r\nGithub 上给某个项目点赞时，故意设置一个不正确的参数命名，会返回状态码 422\r\n\r\n![422](https://shanyue.tech/assets/img/422.c4c88739.png)\r\n\r\n429 Too Many Request\r\n--------------------\r\n\r\n请求过多被限流。\r\n\r\n超过某一个 API 的 Rate Limit 规则，会被限流，返回 429 状态码\r\n\r\n示例: 在 Sentry 中异常上报过于频繁被限流\r\n\r\n500 Internal Server Error\r\n-------------------------\r\n\r\n服务器内部错误，很有可能是应用层未捕获错误而导致整个服务挂掉\r\n\r\n502 Bad Gateway\r\n---------------\r\n\r\nNginx 上常见，从上游应用层未返回响应，上游应用层挂了\r\n\r\n## 503 Service Unavailable\r\n\r\n由于大量流量造成服务忙，稍等一下说不定就能用了\r\n\r\n## 504 Gateway Timeout\r\n\r\n网关超时，上游应用层迟迟未响应\r\n\r\n",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4Mjk0MTg=",
    "number": 37,
    "title": "【Q036】http 状态码中 301，302和307有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NDY4ODQ3NA==",
      "body": "+ 301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。\r\n+ 302，Found。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307\r\n+ 307，Temporary Redirect。临时重定向，在重定向时不会改变 method\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM5NTQ1NjY=",
    "number": 38,
    "title": "【Q037】linux 有哪些发行版，你最喜欢哪一个",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NTAwNjY1Mw==",
      "body": "我最喜欢的Linux发行版是Centos，第二喜欢的是Ubuntu。Centos在服务器上很好用，Ubuntu做开发环境很好用。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "zhangzl419",
        "url": "https://github.com/zhangzl419"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQzMDM3ODE=",
    "number": 39,
    "title": "【Q038】使用 react 实现一个通用的 message 组件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjQzNjE1ODQ=",
    "number": 40,
    "title": "【Q039】redis 的持久化方案有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTQxMDczOQ==",
      "body": "两种方案\r\n\r\n+ RDB，备份数据本身。因此粒度不够细，数据完整性也不是能够很好的保证。但是简单粗暴，适合大量数据\r\n+ AOF，备份命令本身。当恢复数据时，把所有写命令执行一遍即可恢复，粒度细，完整性好。正因为是命令，所以恢复速度慢\r\n\r\n如果需要持久化时，两种方案全开。\r\n\r\nPS：一般 redis 只用到缓存功能，无重要数据，如不涉及消息队列，则持久化可以关掉",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQ4MzAwODA=",
    "number": 41,
    "title": "【Q040】k8s 由那些组件组成",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjQ5ODUyMzY=",
    "number": 42,
    "title": "【Q041】CoW 策略指什么，docker 中有哪些应用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      },
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjU3NzExNTQ=",
    "number": 43,
    "title": "【Q042】docker 中如何查看某个容器消耗的内存和CPU",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NTk4MjU5MA==",
      "body": "``` bash\r\n$ docker stats postgres\r\nCONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS\r\nadb85849e229        postgres            0.00%               3.328MiB / 1.796GiB   0.18%               0B / 0B             874GB / 2.6GB       7\r\n\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MDc3NjY=",
    "number": 44,
    "title": "【Q043】如何使用命令查看一个文件有多少字符以及多少行",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxMzIzMTc2NQ==",
      "body": "wc，及 `word count`，用以统计一个文件的行数、单词数、字符数及文件大小\r\n\r\n``` bash\r\n# 97 - lines\r\n# 177 - words\r\n# 5087 - bytes\r\n$ wc Readme.md\r\n97  177 5087 Readme.md\r\n\r\n# -m 用以统计字符数\r\n$ wc -m Readme.md\r\n3107 Readme.md\r\n```\r\n\r\n\r\n相关问题：\r\n\r\n+ [Vim 中如何查看文件的行数及字符数](https://github.com/shfshanyue/Daily-Question/issues/45)\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MDkzNzk=",
    "number": 45,
    "title": "【Q044】如何使用vim查看文件有多少个字符以及多少行",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg3OTAxMzk2",
        "name": "vim"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxMzIzMDA1OA==",
      "body": "在 `Normal` 模式下，可以通过快捷键 `g + <Ctrl-g>` 查看文件行数、列数、字符数及所占字节大小，此时状态栏(即 vim 最底下一行)显示如下：\r\n\r\n``` txt\r\nCol 1 of 10; Line 28 of 161; Word 71 of 377; Char 636 of 4315; Byte 768 of 4969\r\n```\r\n\r\n如果**仅仅想要了解文件行数及列数**，可以通过快捷键 `<Ctrl-g>` 查看，此时状态栏如下\r\n\r\n``` txt\r\n\"package.json\" 行 14 / 42 --33%-- 列 5\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/97083635-f725c680-1643-11eb-8716-75a88ad14edc.png)\r\n\r\n如果**仅仅想要了解文件行数**，可以通过快捷键 `G` 直接移动到文件最后一行来查看行数\r\n\r\n## 相关问题：\r\n\r\n+ [Linux 中如何使用命令查看文件的行数及字符数](https://github.com/shfshanyue/Daily-Question/issues/44)\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MjAwNDE=",
    "number": 46,
    "title": "【Q045】如何把一个 CIDR 地址转化为IP地址范围段",
    "body": "如 `172.16.0.0/27` 的IP范围是多少",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjU4MjcwODc=",
    "number": 47,
    "title": "【Q046】docker 中的网络隔离是如何实现的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1NjAxODkxNQ==",
      "body": "参考: https://docs.docker.com/network/iptables/",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjY2MTA3NDk=",
    "number": 48,
    "title": "【Q047】如何设计一个高并发系统",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjY2MTM0MTI=",
    "number": 49,
    "title": "【Q048】如何实现一个优先级队列",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MjY5MjA3MTI=",
    "number": 50,
    "title": "【Q049】什么是守护进程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzYyOQ==",
      "body": "守护进程，可以被认为是后台进程，当你把控制台关闭时，它仍然还会运行。\r\n\r\n当然 - 这只是表面，从更深层次看呢？",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjcwNjMyNjg=",
    "number": 51,
    "title": "【Q050】http 状态码 502 和 504 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxNTkyMTk3Mg==",
      "body": "这两种异常状态码都与网关 Gateway 有关，首先明确两个概念\r\n\r\n+ Proxy (Gateway)，反向代理层或者网关层。在公司级应用中一般使用 Nginx 扮演这个角色\r\n+ Application (upstream serrver)，应用层服务，作为 Proxy 层的上游服务。在公司中一般为各种语言编写的服务器应用，如 Go/Java/Python/PHP/Node 等\r\n\r\n此时关于 502 与 504 的区别就很显而易见\r\n\r\n+ `502 Bad Gateway`。一般表现为你自己写的应用层服务(Java/Go/PHP)挂了，网关层无法接收到响应\r\n+ `504 Gateway Timeout`。一般表现为应用层服务 (upstream) 超时，如查库操作耗时十分钟，超过了 Nginx 配置的超时时间",
      "reactions": {
        "totalCount": 6
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc0NzQxMDI=",
    "number": 52,
    "title": "【Q051】简述一下 graphql，它的引进有什么好处",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
        "name": "graphql"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mjc0NzQ0MTc=",
    "number": 53,
    "title": "【Q052】graphql 的引进有什么风险，以及性能问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
        "name": "graphql"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mjc1MzEwMDA=",
    "number": 54,
    "title": "【Q053】什么是对象存储，与块存储和文件存储有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mjc3MDM1MTU=",
    "number": 55,
    "title": "【Q054】简述TCP 的三次握手",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNTkzMw==",
      "body": "我：你在吗？\r\n他： 我在的。\r\n我： 那开始聊天吧",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "WenHaiYana",
        "url": "https://github.com/WenHaiYana"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc3ODA5MDQ=",
    "number": 56,
    "title": "【Q055】如何在 linux 中打印所有环境变量",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTY3OTYxNA==",
      "body": "``` shell\r\n$ printenv\r\nXDG_SESSION_ID=10536\r\nHOSTNAME=shanyue\r\nTERM=xterm-256color\r\nSHELL=/bin/bash\r\nHISTSIZE=1000\r\nSSH_CLIENT=124.200.184.74 16003 22\r\nSSH_TTY=/dev/pts/0\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc4NzYwMjU=",
    "number": 57,
    "title": "【Q056】什么是服务降级",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mjc4NzkzNzE=",
    "number": 58,
    "title": "【Q057】什么是熔断机制，微服务如何做熔断",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0ODU0OA==",
      "body": "TODO",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc5MzkyNjU=",
    "number": 59,
    "title": "【Q058】什么是负载均衡",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mjg0Njk3NTU=",
    "number": 60,
    "title": "【Q059】四层负载均衡与七层负载均衡有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzQ5OQ==",
      "body": "TODO",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjg0NzAzNTI=",
    "number": 61,
    "title": "【Q060】你们项目中的计划任务是如何组织的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzU1NQ==",
      "body": "TODO\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjg0NzE0MDg=",
    "number": 62,
    "title": "【Q061】如何判断两个链表是否相交",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MzA5MDI0MQ==",
      "body": "只判断链表相交，好一点的方式是用双指针+哈希表。\r\n同时遍历a，b链表，如果当前a和b所在元素不在哈希表，则将元素加入哈希表。知道找到哈希表里面重复元素则算相交。时间复杂度o(max(a, b))是a，b不想交部分的较大值。空间复杂度是o(a + b)，a和b不想交部分。\r\n\r\n第二种是遍历a和b，判断尾指针是否相等。时间复杂度o(a + b)，空间复杂度o(1)。\r\n\r\n进阶问题是，找到相交链表的第一个相交点",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "wython",
        "url": "https://github.com/wython"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwMzQxMDE=",
    "number": 63,
    "title": "【Q062】RPC 与 REST 有什么优劣",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzQ1Mw==",
      "body": "TODO",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwMzc1Mzk=",
    "number": 64,
    "title": "【Q063】SIGINT SIGTERM SIGKILL 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzM5OA==",
      "body": "TODO",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwNDE0MzU=",
    "number": 65,
    "title": "【Q064】如何实现服务发现 (Service Discovery)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzM0NQ==",
      "body": "TODO: k8s 的服务发现是如何实现的",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwNDE4MzI=",
    "number": 66,
    "title": "【Q065】有没有使用过 oss，对象存储相比块存储和文件存储有什么优缺点",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzIzOA==",
      "body": "OSS 兼具分布式与读取速度的平衡吧",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkxMzEzOTk=",
    "number": 67,
    "title": "【Q066】如何使用 react hooks 实现 useFetch 请求数据",
    "body": "比如设计成 `useFetch` 这种形式，它的 API 应该如何设计",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0NDYyMg==",
      "body": "可以参考 [How to fetch data with React Hooks?](https://www.robinwieruch.de/react-hooks-fetch-data)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkxNDIxODg=",
    "number": 68,
    "title": "【Q067】react 如何使用 render prop component 请求数据",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0ODM4Mg==",
      "body": "参考: <https://www.robinwieruch.de/react-fetching-data#how-to-fetch-data-in-render-props>",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk2MjYxNzA=",
    "number": 69,
    "title": "【Q068】React Portal 有哪些使用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTY0ODY2MQ==",
      "body": "> Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.\r\n\r\n在以前， `react` 中所有的组件都会位于 `#app` 下，而使用 `Portals` 提供了一种脱离 `#app` 的组件。\r\n\r\n因此 `Portals` 适合脱离文档流(out of flow) 的组件，特别是 `position: absolute` 与 `position: fixed` 的组件。比如模态框，通知，警告，goTop 等。\r\n\r\n以下是官方一个模态框的示例，可以在以下地址中测试效果 <https://codepen.io/gaearon/pen/jGBWpE?editors=1010>\r\n\r\n\r\n``` html\r\n<html>\r\n  <body>\r\n    <div id=\"app\"></div>\r\n    <div id=\"modal\"></div>\r\n    <div id=\"gotop\"></div>\r\n    <div id=\"alert\"></div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n\r\n``` jsx\r\nconst modalRoot = document.getElementById('modal');\r\n\r\nclass Modal extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.el = document.createElement('div');\r\n  }\r\n\r\n  componentDidMount() {\r\n    modalRoot.appendChild(this.el);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    modalRoot.removeChild(this.el);\r\n  }\r\n\r\n  render() {\r\n    return ReactDOM.createPortal(\r\n      this.props.children,\r\n      this.el,\r\n    );\r\n  }\r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk2MjY5OTE=",
    "number": 70,
    "title": "【Q069】什么是 virtual DOM，它的引入带了什么好处",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3NDAyNQ==",
      "body": "- 虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。\r\n-  vdom 把渲染过程抽象化了，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。\r\n\r\n\r\n- Virtual DOM 在牺牲(牺牲很关键)部分性能的前提下，增加了可维护性，这也是很多框架的通性。\r\n实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM中，用最小的代价来更新DOM，提高效率(提升效率要想想是跟哪个阶段比提升了效率，别只记住了这一条)。\r\n- 打开了函数式 UI 编程的大门。\r\n- 可以渲染到 DOM 以外的端，使得框架跨平台，比如 ReactNative，React VR 等。\r\n- 可以更好的实现 SSR，同构渲染等。这条其实是跟上面一条差不多的。\r\n- 组件的高度抽象化。\r\n\r\n> 虚拟 DOM 的缺点\r\n- 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。\r\n- 虚拟 DOM 需要在内存中的维护一份 DOM 的副本(更上面一条其实也差不多，上面一条是从速度上，这条是空间上)。\r\n- 如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以，如果你有一个DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。\r\n",
      "reactions": {
        "totalCount": 6
      },
      "author": {
        "login": "libin1991",
        "url": "https://github.com/libin1991"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk5MzIxOTA=",
    "number": 71,
    "title": "【Q070】如何用 linux 命令输出文件的特定行",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU1OTYzNTA3Mg==",
      "body": "通常使用 `sed` 命令打印特定行，如\r\n\r\n``` bash\r\n# -n: 按特定格式打印\r\n# 100p: 指打印第一百行\r\n$ sed -n 100p Readme.md\r\n```\r\n\r\n但 `sed` 打印的本领，远不止于此，除了打印特定行，还可以打印一段范围的行，如\r\n\r\n``` bash\r\n# 打印文件中第 100-120 行\r\n$ sed -n 100,120p Readme.md\r\n\r\n# 打印文件中第 100-120 行\r\n$ sed -n 100,+20p Readme.md\r\n```\r\n\r\n还有一种本办法，`head`/`tail` 的组合命令，以要输出第100行为例\r\n\r\n``` bash\r\n# 输出前100行，再通过 pipe，输出最后一行\r\n$ head -100 Readme.md | tail -1\r\n```\r\n\r\n关于 `sed` 更多的用法可以参考我的文章: [sed 命令详解及示例](https://shanyue.tech/op/linux-sed.html)\r\n\r\n## 总结\r\n\r\n两种方法\r\n\r\n1. `sed -n 100p Readme.md`\r\n1. `head -100 Readme.md | tail -1`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1Nzc4MjA=",
    "number": 72,
    "title": "【Q071】react 与 vue 数组中 key 的作用是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxOTMwODgxNQ==",
      "body": "diff算法需要比对虚拟dom的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode会首先判断key和标签名是否一致，如果一致再去判断子节点一致，使用key可以帮助diff算法提升判断的速度，在页面重新渲染时更快消耗更少",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "RunToGet",
        "url": "https://github.com/RunToGet"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODYyNDI=",
    "number": 73,
    "title": "【Q072】webpack 是用来做什么的，原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTE3MTUzNg==",
      "body": "https://juejin.im/post/5e01de37f265da33ab637daf?utm_source=gold_browser_extension",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "lf75152798",
        "url": "https://github.com/lf75152798"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODgzMTQ=",
    "number": 74,
    "title": "【Q073】webpack 中的 loader 的作用是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTM4MTQ5Mw==",
      "body": "哎  lodaer 的作用就是处理单个文件的  跳到这啥都没有",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "wang120140",
        "url": "https://github.com/wang120140"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODg1MTY=",
    "number": 75,
    "title": "【Q074】有没有自己写过一个webpack的loader",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTM4MTUyOA==",
      "body": "我看过源码 没有写过",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "wang120140",
        "url": "https://github.com/wang120140"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODg2MTQ=",
    "number": 76,
    "title": "【Q075】webpack 中plugin的作用是什么，有没有自己写过",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODkyODU=",
    "number": 77,
    "title": "【Q076】如何设计一个短网址生成服务",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjMzNzQ=",
    "number": 78,
    "title": "【Q077】使用 webpack 时如何优化项目体积",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMDEzMzg3Mg==",
      "body": "使用用uglyfly进行代码压缩，使用commonsChunk分离第三方代码",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "jzenzhang",
        "url": "https://github.com/jzenzhang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjM4NTA=",
    "number": 79,
    "title": "【Q078】什么是 HMR，原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ0NjY=",
    "number": 80,
    "title": "【Q079】简述 http 的缓存机制",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyMDg4ODE1OA==",
      "body": "Http 缓存分为以下两种，两者都是通过 HTTP 响应头控制缓存\r\n\r\n1. 强制缓存\r\n1. 协商缓存\r\n\r\n## 强制缓存\r\n\r\n再次请求时无需再向服务器发送请求\r\n\r\n``` bash\r\n              client         server\r\nGET /a.ab389z.js ------->\r\n                      <------- 200 OK\r\n(再也不会发请求)\r\n```\r\n\r\n与之相关的 Response Headers 有以下几个\r\n\r\n+ `Expires`\r\n\r\n  这个头部也是丧心病狂：使用绝对时间，且有固定的格式 <https://tools.ietf.org/html/rfc822#section-5.1>\r\n\r\n  ``` bash\r\n  Expires: Mon, 25 Oct 2021 20:11:12 GMT\r\n  ```\r\n\r\n+ `Cache-Control`，具有强大的缓存控制能力\r\n\r\n  常用的有以下两个\r\n\r\n  + `no-cache`，每次请求需要校验服务器资源的新鲜度\r\n  + `max-age=31536000`，浏览器在一年内都不需要向服务器请求资源\r\n\r\n## 协商缓存\r\n\r\n再次请求时，需要向服务器校验新鲜度，如果资源是新鲜的，返回 304，从浏览器获取资源\r\n\r\n``` bash\r\n           client         server\r\nGET /a.js   ----------->\r\n                   <----------- 200 OK\r\nGET /a.js   ----------->\r\n                   <----------- 304 Not Modified\r\n```\r\n\r\n与之相关的 Response Headers 有以下几个\r\n\r\n+ `Last-Modified`/`Modified-Since`\r\n+ `Etag`",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ2Mzk=",
    "number": 81,
    "title": "【Q080】使用 webpack 打包时，如何更好地利用 long term cache",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMjM2MjM1NQ==",
      "body": "查阅了很多前辈的资料，总结大致如下：（最后附上链接）\r\nlong term cache即“持久性缓存”\r\nUse [chunkhash] to add a content-dependent cache-buster to each file.\r\nUse compiler stats to get the file names when requiring resources in HTML.\r\nGenerate the chunk-manifest JSON and inline it into the HTML page before loading resources.\r\nEnsure that the entry point chunk containing the bootstrapping code doesn’t change its hash over time for the same set of dependencies.\r\n\r\n1.使用 [chunkhash] 为每个文件增加一个内容相关的缓存清道夫；\r\nSeparate development and production configs and use [name].js for development and [name].[chunkhash].js in production.\r\n\r\n2.使用编译统计在 HTML 中获取资源时取得文件名；[html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin)\r\n\r\n3.生成 JSON 格式的模块清单文件，并在 HTML 页面加载资源之前内联进去；\r\nTo fix that, we should use [chunk-manifest-webpack-plugin](https://github.com/diurnalist/chunk-manifest-webpack-plugin) which will extract that manifest to a separate JSON file. \r\n\r\n4.保证包含启动代码的入口块不会对于同样的依赖生成不同的哈希值；（3.x 以前的版本是使用 CommonsChunkPlugin 来做代码分离的——将公共库(vendor)和应用程序代码分离开来，并创建一个显式的vendor chunk以防止它频繁更改。而 webpack 4.x 则是把相关的功能包到了optimization.splitChunks中，直接使用该配置就可以实现代码分离。）\r\n\r\n[代码示例](https://github.com/okonet/webpack-long-term-cache-demo)版本：\"webpack\": \"^1.10.1\"\r\n资料来源：\r\n[webpack中文文档](https://www.webpackjs.com/guides/caching/)\r\n[Webpack Freestyle 之 Long Term Cache](https://zhuanlan.zhihu.com/p/27710902)\r\n[Long-term caching of static assets with Webpack](https://codeburst.io/long-term-caching-of-static-assets-with-webpack-1ecb139adb95#.9ro7cpngr)\r\n[用 webpack 实现持久化缓存](https://sebastianblade.com/using-webpack-to-achieve-long-term-cache/#webpack)\r\n[Webpack 的静态资源持久缓存](https://zcfy.cc/article/long-term-caching-of-static-assets-with-webpack-1204.html)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "SageSanyue",
        "url": "https://github.com/SageSanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ3OTk=",
    "number": 82,
    "title": "【Q081】http proxy 的原理是什么",
    "body": "如 `webpack-dev-server` 可以设置 proxy，`nginx` 也可以设置",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NTM1NTQyMA==",
      "body": "todo",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ5NzM=",
    "number": 83,
    "title": "【Q082】随着 http2 的发展，webpack 有没有更好的打包方案",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjUyMDk=",
    "number": 84,
    "title": "【Q083】网站性能优化都有哪些点",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjUzODQ=",
    "number": 85,
    "title": "【Q084】随着 http2 的发展，前端性能优化中的哪些传统方案可以被替代",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NjA4MA==",
      "body": "1. 雪碧图\r\n1. 资源文件合并",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjU0NzI=",
    "number": 86,
    "title": "【Q085】http2 与 http1.1 有什么不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODkxNTczOQ==",
      "body": "1. 多路复用\r\n1. 二进制分帧\r\n1. server push\r\n1. 头部压缩\r\n\r\n可参考文章 [http2 详解](https://juejin.im/post/5b88a4f56fb9a01a0b31a67e)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjU2Nzk=",
    "number": 87,
    "title": "【Q086】webpack 中 tree shaking 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODk1MjkwNA==",
      "body": "应该是基于es6 modules的静态分析",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "coderyyx",
        "url": "https://github.com/coderyyx"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjYxMTc=",
    "number": 88,
    "title": "【Q087】什么是 CNAME 记录和 A 记录",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NTgwNg==",
      "body": "CNAME：域名  -> 域名\r\nA：域名 -> IP",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjY0Nzk=",
    "number": 89,
    "title": "【Q088】如何实现 promise.map，并限制并发数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NTQyNTQ4NQ==",
      "body": "怎么实现",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "william-xue",
        "url": "https://github.com/william-xue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjY4NTc=",
    "number": 90,
    "title": "【Q089】vue 中 v-if 和 v-show 的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MTkzNDA3NQ==",
      "body": "> v-show always compiles and renders everything - it simply adds the \"display: none\" style to the element. It has a higher initial load cost, but toggling is very cheap.\r\n> Incomparison, v-if is truely conditional: it is lazy, so if its initial condition is false, it won't even do anything. This can be good for initial load time. When the condition is true, v-if will then compile and render its content. Toggling a v-if block actually tearsdown everything inside it, e.g. Components inside v-if are acually destroyed and re-created when toggled, so toggling a huge v-if block can be more expensive than v-show.\r\n\r\nv-show 总是会进行编译和渲染的工作 - 它只是简单的在元素上添加了 `display: none;` 的样式。v-show 具有较高的初始化性能成本上的消耗，但是使得转换状态变得很容易。\r\n相比之下，v-if 才是真正「有条件」的：它的加载是惰性的，因此，若它的初始条件是 false，它就不会做任何事情。这对于初始加载时间来说是有益的，当条件为 true 时，v-if 才会编译并渲染其内容。切换 v-if 下的块儿内容实际上时销毁了其内部的所有元素，比如说处于v-if下的组件实际上在切换状态时会被销毁并重新生成，因此，切换一个较大v-if块儿时会比v-show消耗的性能多。",
      "reactions": {
        "totalCount": 3
      },
      "author": {
        "login": "zhaofeihao",
        "url": "https://github.com/zhaofeihao"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjcwNTE=",
    "number": 91,
    "title": "【Q090】vue 中 computed 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MzA1MDQzMw==",
      "body": "要讲清楚，computed原理，首先得讲vue响应式原理，因为computed的实现是基于Watcher对象的。\r\n那么vue的响应式原理是什么呢，众所周知，vue是基于Object.defineProperty实现监听的。在vue初始化数据data和computed数据过程中。会涉及到以下几个对象：\r\n1. Observe对象\r\n2. Dep对象\r\n3. Watch对象\r\nObserve对象是在data执行响应式时候调用，因为computed属性基于响应式属性，所以其不需要创建Observe对象。\r\nDep对象主要功能是做依赖收集，有个属性维护多个Watch对象，当更新时候循环调用每个Watch执行更新。\r\nWatch对象主要是用于更新，而且是收集的重点对象。\r\n\r\n这里谈到computed计算属性，首先要知道，其有两种定义方式，一种是方法，另一种是get，set属性。而且，其内部监听的对象必须是已经定义响应式的属性，比如data的属性vuex的属性。\r\n\r\nvue在创建computed属性时候，会循环所有计算属性，每一个计算属性会创建一个watch，并且在通过defineProperty定义监听，在get中，计算属性工作是做依赖收集，在set中，计算属性重要工作是重新执行计算方法，这里需要多补充一句，因为computed是懒执行，也就是说第一次初始化之后，变不会执行计算，下一次变更执行重新计算是在set中。\r\n\r\n另一个补充点是依赖收集的时机，computed收集时机和data一样，是在组件挂载前，但是其收集对象是自己属性对应的watch，而data本身所有数据对应一个watch。\r\n\r\n以下附计算属性源码验证说法：\r\n\r\n```typescript\r\n\r\nfunction initComputed (vm: Component, computed: Object) {\r\n  // $flow-disable-line\r\n  const watchers = vm._computedWatchers = Object.create(null)\r\n  // computed properties are just getters during SSR\r\n  const isSSR = isServerRendering()\r\n\r\n  for (const key in computed) {\r\n    const userDef = computed[key]\r\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\r\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\r\n      warn(\r\n        `Getter is missing for computed property \"${key}\".`,\r\n        vm\r\n      )\r\n    }\r\n\r\n    if (!isSSR) {\r\n      // create internal watcher for the computed property.\r\n      watchers[key] = new Watcher(\r\n        vm,\r\n        getter || noop,\r\n        noop,\r\n        computedWatcherOptions\r\n      )\r\n    }\r\n\r\n    // component-defined computed properties are already defined on the\r\n    // component prototype. We only need to define computed properties defined\r\n    // at instantiation here.\r\n    if (!(key in vm)) {\r\n      defineComputed(vm, key, userDef)\r\n    } else if (process.env.NODE_ENV !== 'production') {\r\n      if (key in vm.$data) {\r\n        warn(`The computed property \"${key}\" is already defined in data.`, vm)\r\n      } else if (vm.$options.props && key in vm.$options.props) {\r\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm)\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n可以看到，在执行new Watcher之前，会对计算属性做判断，判断其是否为函数，如果不是则取getter。这是因为计算属性有两种定义方式。之后第二步是执行deineCoumputed。这一步只是简单的调用defineProterty我就不贴代码了。\r\n\r\n关于计算属性的getter和setter定义如下：\r\n重点关注get的懒加载部分，和Watcher的定义\r\n```typescript\r\nfunction createComputedGetter (key) {\r\n  return function computedGetter () {\r\n    const watcher = this._computedWatchers && this._computedWatchers[key]\r\n    if (watcher) {\r\n      if (watcher.dirty) {\r\n        watcher.evaluate()\r\n      }\r\n      if (Dep.target) {\r\n        watcher.depend()\r\n      }\r\n      return watcher.value\r\n    }\r\n  }\r\n}\r\n\r\nfunction createGetterInvoker(fn) {\r\n  return function computedGetter () {\r\n    return fn.call(this, this)\r\n  }\r\n}\r\n```\r\n",
      "reactions": {
        "totalCount": 3
      },
      "author": {
        "login": "wython",
        "url": "https://github.com/wython"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjcxNzg=",
    "number": 92,
    "title": "【Q091】vue-loader 的实现原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      },
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzE4MTgyMzA=",
    "number": 93,
    "title": "【Q092】react 中 ref 是干什么用的，有哪些使用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDM4ODY5MQ==",
      "body": "**取得深层次的dom的结构。进行操作；我用过的主要是对表格滚动条的操作**",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "senbochen",
        "url": "https://github.com/senbochen"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzI1NzgxMzc=",
    "number": 94,
    "title": "【Q093】如何实现一个 LRU",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzI2MzUxNDc=",
    "number": 95,
    "title": "【Q094】你们的前端代码上线部署一次需要多长时间，需要人为干预吗",
    "body": "更短的部署时间，更少的人为干预，更有利于敏捷开发",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NDkyMA==",
      "body": "TODO",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyMTI2OTc=",
    "number": 96,
    "title": "【Q095】k8s 中的 QoS 有哪几种类型",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjAzNzYzNw==",
      "body": "参考官方文档：[Configure Quality of Service for Pods\r\n](https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/)，总结如下\r\n\r\n有三种类型 `Guaranteed`，`Burstable` 与 `BestEffort `\r\n\r\n+ `Guaranteed`\r\n    + Pod 里的每个容器都必须有内存 `resources.limits` 和 `resources.requests`，而且必须是一样的\r\n    + Pod 里的每个容器都必须有 CPU `resources.limits` 和 `resources.requests`，而且必须是一样的\r\n+ `Burstable`\r\n    + Pod 里至少有一个容器有内存或者 CPU `resources.requests`\r\n+ `BestEffort`\r\n    + 不设置 `resources.requests` 和 `resources.limits`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyNjAxNzg=",
    "number": 97,
    "title": "【Q096】cron 表达式 (* 10 * * *) 会如何触发",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTA3Mg==",
      "body": "每天十点，每分钟都会执行一次",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyNjIyOTE=",
    "number": 98,
    "title": "【Q097】cron 表达式 (30 10 * * *) 会如何触发",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTIxMw==",
      "body": "每天十点半执行一次",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyOTUyMzQ=",
    "number": 99,
    "title": "【Q098】在 linux 中如何查看 cron 执行的情况",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTk0NA==",
      "body": "在 `centos` 中，查看日志文件\r\n\r\n``` bash\r\n$ tail -f /var/log/cron\r\nDec  5 19:30:01 8 CROND[24068]: (root) CMD (echo hello, world)\r\nDec  5 19:31:01 8 CROND[24084]: (root) CMD (echo hello, world)\r\nDec  5 19:31:01 8 CROND[24083]: (root) CMD (echo hello)\r\nDec  5 19:32:01 8 CROND[24094]: (root) CMD (echo hello, world)\r\nDec  5 19:32:01 8 CROND[24093]: (root) CMD (echo hello)\r\nDec  5 19:33:01 8 CROND[24104]: (root) CMD (echo hello, world)\r\nDec  5 19:33:01 8 CROND[24103]: (root) CMD (echo hello)\r\nDec  5 19:34:01 8 CROND[24113]: (root) CMD (echo hello)\r\nDec  5 19:34:01 8 CROND[24114]: (root) CMD (echo hello, world)\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM0MDI4NzA=",
    "number": 100,
    "title": "【Q099】git 如何查看某个文件的提交历史",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
        "name": "git"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjE2ODM3OA==",
      "body": "``` bash\r\ngit log -p file\r\n```",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM0NDIzMzk=",
    "number": 101,
    "title": "【Q100】如何使用 react/vue 实现一个 message API",
    "body": "可以实现如下 API\r\n\r\n`message.info()`\r\n`message.success()`",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTQwMzE1MQ==",
      "body": "```\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n// info组件\r\nimport Info from 'info';\r\n// success组件\r\nimport Success from 'success';\r\n\r\nfunction createMessage(message, Com) {\r\n\r\n  let el = document.createElement('div');\r\n\r\n  document.body.appendChild(el);\r\n\r\n  const component = React.createElement(Com, {\r\n    message\r\n  });\r\n\r\n  ReactDOM.render(component, el);\r\n}\r\n\r\nconst message = {\r\n  info(message) {\r\n    return createMessage(message, Info);\r\n  },\r\n  success(message) {\r\n    return createMessage(message, Success);\r\n  },\r\n};\r\n\r\nexport default message;\r\n```\r\n主要实现思路就是创建一个div到body下，然后利用ReactDOM.render将组件渲染到这个容器下，这只是一个简单的实现，没实现关闭和多次调用",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "allan-hx",
        "url": "https://github.com/allan-hx"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM3NTE1MTA=",
    "number": 102,
    "title": "【Q101】你们后端代码上线部署一次需要多长时间",
    "body": "关键在于考虑开发人员对项目部署流程的了解",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MDA1ODE1Ng==",
      "body": "30分钟左右",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "fmleing",
        "url": "https://github.com/fmleing"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM4MzM1Mzk=",
    "number": 103,
    "title": "【Q102】有没有用 npm 发布过 package，如何发布",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyOTM4NzI3MA==",
      "body": "## 步骤\r\n\r\n1. 注册 npm 账号 https://www.npmjs.com/\r\n2. 本地通过命令行 `npm login` 登陆\r\n3. 进入到项目目录下（与 package.json 同级），在 package.json 中指定发布文件、文件夹\r\n```json\r\n{\r\n  \"name\": \"pkg-xxx\",\r\n  \"version\": \"0.0.1\",\r\n  \"main\": \"lib/index.js\",\r\n  \"module\": \"esm/index.js\",\r\n  \"typings\": \"types/index.d.ts\",\r\n  \"files\": [\r\n    \"CHANGELOG.md\",\r\n    \"lib\",\r\n    \"esm\",\r\n    \"dist\",\r\n    \"types\",\r\n  ],\r\n  ...\r\n}\r\n```\r\n执行 `npm publish --registry=https://registry.npmjs.org/` 即可发布\r\n\r\n## 其他\r\n\r\n还可以配合 [GitHub Packages](https://docs.github.com/en/free-pro-team@latest/packages/using-github-packages-with-your-projects-ecosystem/configuring-npm-for-use-with-github-packages) 发布",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "wangkailang",
        "url": "https://github.com/wangkailang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5MTQ3NDA=",
    "number": 104,
    "title": "【Q103】你在工作中遇到最有挑战的事情是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MDA1NzQ5NQ==",
      "body": "一个人3天负责完成本来评估1周工作量的需求变更，在刚接手项目进行维护的前提下，不熟悉需要更改的业务代码实现。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "fmleing",
        "url": "https://github.com/fmleing"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5MTQ5MTk=",
    "number": 105,
    "title": "【Q104】你在工作中遇到最受挫折的事情是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzM5OTgwODg=",
    "number": 106,
    "title": "【Q105】你为什么从上家公司离职",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MDA5NTk=",
    "number": 107,
    "title": "【Q106】什么是IO多路复用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwMTQzNg==",
      "body": "假设你的服务器要同时处理 100 个 `socket` 连接\r\n\r\n1. 开一个线程，挨个处理。这就没法处理并发了\r\n1. 开100个线程，分别处理。这么多的线程在内核态频频进进出出也很消耗性能\r\n1. 开一个线程，去检查 `socket` 是否就绪，如果就绪则再开一个线程去处理。这就是IO多路复用了\r\n\r\n`select`、`poll`、`epoll` 是三中典型的IO多路复用的系统调用，但实际上现在 `epoll` 使用的最多。当你使用 `strace` 查看 `nodejs` 某个服务的系统调用时，将会发现 `nodejs` 就是使用了 `epoll`\r\n\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MDg0MzU=",
    "number": 108,
    "title": "【Q107】什么是 Basic Auth 和 Digest Auth",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MTY5MDI=",
    "number": 109,
    "title": "【Q108】gzip 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwNjgyNg==",
      "body": "`gzip` 使用了 `LZ77` 算法与 `Huffman` 编码来压缩文件，重复度越高的文件可压缩的空间就越大。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0NzcxNzA=",
    "number": 110,
    "title": "【Q109】可以对图片开启 gzip 压缩吗，为什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwMzYyMw==",
      "body": "不需要开启，如果开启的话，有可能使图片变的更大。如果你注意一些网站的 img 资源时，就会发现他们都没有开启 `gzip`\r\n\r\n参考: https://webmasters.stackexchange.com/questions/8382/is-gzipping-images-worth-it-for-a-small-size-reduction-but-overhead-compressing\r\n\r\n> **Don't use gzip for image or other binary files.**\r\n>\r\n> Image file formats supported by the web, as well as videos, PDFs and other binary formats, are already compressed; using gzip on them won't provide any additional benefit, and can actually make them larger. To compress images, see Optimize images.",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU0NTc0OTg=",
    "number": 111,
    "title": "【Q110】http 的请求报文与响应报文的格式是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2MzYzNzUzMA==",
      "body": "以 `nc` 模拟 http 报文如下\r\n\r\n``` bash\r\n$ nc www.baidu.com 80\r\nGET / HTTP/1.1\r\nHost: www.baidu.com\r\n\r\nHTTP/1.1 200 OK\r\nAccept-Ranges: bytes\r\nCache-Control: no-cache\r\nConnection: Keep-Alive\r\nContent-Length: 14615\r\nContent-Type: text/html\r\nDate: Tue, 10 Dec 2019 02:48:44 GMT\r\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\r\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\r\nPragma: no-cache\r\nServer: BWS/1.1\r\nSet-Cookie: BAIDUID=F0FC6B3A056DEA285F51A1F2F8A170BB:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: BIDUPSID=F0FC6B3A056DEA285F51A1F2F8A170BB; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: PSTM=1575946124; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: BAIDUID=F0FC6B3A056DEA287CB2B9422E09E30E:FG=1; max-age=31536000; expires=Wed, 09-Dec-20 02:48:44 GMT; domain=.baidu.com; path=/; version=1; comment=bd\r\nTraceid: 1575946124058431156210725656341129791126\r\nVary: Accept-Encoding\r\nX-Ua-Compatible: IE=Edge,chrome=1\r\n\r\n<!DOCTYPE html><!--STATUS OK-->\r\n........内容省略\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU0NzEwNzM=",
    "number": 112,
    "title": "【Q111】http 响应头中的 ETag 值是如何生成的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2Mzg5NDAzNA==",
      "body": "关于 `etag` 的生成需要满足几个条件，至少是宽松满足\r\n\r\n1. 当文件更改时，`etag` 值必须改变。\r\n1. **尽量**便于计算，不会特别耗 CPU。这样子利用摘要算法生成 (MD5, SHA128, SHA256) 需要慎重考虑，因为他们是 CPU 密集型运算\r\n1. **必须**横向扩展，分布式部署时多个服务器节点上生成的 `etag` 值保持一致。这样子 `inode` 就排除了\r\n\r\n> 关于服务器中 `etag` 如何生成可以参考 [HTTP: Generating ETag Header](https://stackoverflow.com/questions/4533/http-generating-etag-header)\r\n\r\n以上几个条件是理论上的成立条件，那在真正实践中，应该如何处理？\r\n\r\n我们来看一下 `nginx` 中是如何做的\r\n\r\n## nginx 中 ETag 的生成\r\n\r\n我翻阅了 `nginx` 的源代码，并翻译成伪代码如下：由 last_modified 与 content_length 拼接而成\r\n\r\n``` js\r\netag = header.last_modified + header.content_lenth\r\n```\r\n\r\n可见源码位置，并在以下贴出: [ngx_http_core_modules.c](https://github.com/nginx/nginx/blob/6c3838f9ed45f5c2aa6a971a0da3cb6ffe45b61e/src/http/ngx_http_core_module.c#L1582)\r\n\r\n``` c\r\netag->value.len = ngx_sprintf(etag->value.data, \"\\\"%xT-%xO\\\"\",\r\n                                  r->headers_out.last_modified_time,\r\n                                  r->headers_out.content_length_n)\r\n                      - etag->value.data;\r\n```\r\n\r\n**总结：`nginx` 中 `etag` 由响应头的 `Last-Modified` 与 `Content-Length` 表示为十六进制组合而成。**\r\n\r\n随手在我的k8s集群里找个 `nginx` 服务测试一下\r\n\r\n``` bash\r\n$ curl --head 10.97.109.49\r\nHTTP/1.1 200 OK\r\nServer: nginx/1.16.0\r\nDate: Tue, 10 Dec 2019 06:45:24 GMT\r\nContent-Type: text/html\r\nContent-Length: 612\r\nLast-Modified: Tue, 23 Apr 2019 10:18:21 GMT\r\nConnection: keep-alive\r\nETag: \"5cbee66d-264\"\r\nAccept-Ranges: bytes\r\n```\r\n\r\n由 `etag` 计算 `Last-Modified` 与 `Content-Length`，使用 `js` 计算如下，结果相符\r\n\r\n``` js\r\n> new Date(parseInt('5cbee66d', 16) * 1000).toJSON()\r\n\"2019-04-23T10:18:21.000Z\"\r\n> parseInt('264', 16)\r\n612\r\n```\r\n\r\n## Nginx 中的 ETag 算法及其不足\r\n\r\n协商缓存用来计算资源是否返回 304，我们知道协商缓存有两种方式\r\n\r\n+ `Last-Modified`/`if-Modified-Since`\r\n+ `ETag`/`If-None-Match`\r\n\r\n既然在 `nginx` 中 `ETag` 由 `Last-Modified` 和 `Content-Length` 组成，那它便算是一个加强版的 `Last-Modified` 了，那加强在什么地方呢？\r\n\r\n**`Last-Modified` 是由一个 `unix timestamp` 表示，则意味着它只能作用于秒级的改变，而 nginx 中的 ETag 添加了文件大小的附加条件**\r\n\r\n那下一个问题：[如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改](https://github.com/shfshanyue/Daily-Question/issues/113)\r\n\r\n答案：不能。\r\n\r\n**因此使用 nginx 计算 304 有一定局限性：在 1s 内修改了文件并且保持文件大小不变。但这种情况出现的概率极低就是了，因此在正常情况下可以容忍一个不太完美但是高效的算法。**\r\n\r\n## 相关问题\r\n\r\n+ [如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改](https://github.com/shfshanyue/Daily-Question/issues/113)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU1Njc3NTk=",
    "number": 113,
    "title": "【Q112】如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxNjI2NzE4MA==",
      "body": "> 比如 nginx 中的 etag 由 last_modified 与 content_length 组成，而 last_modified 又由 mtime 组成。\r\n> \r\n> 那Etag是怎么解决last_modified，当编辑文件却未更改文件时间的问题？\r\n\r\n1. 此时文件大小有可能发生更改，ETag 会改变\r\n1. 此时文件大小没有发生更改，ETag 不会改变。但这需要极其苛刻的条件：1s 内更改文件，并且保持文件大小不变。这种情况出现概率很低，因此忽略了",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU1ODU2ODY=",
    "number": 114,
    "title": "【Q113】如何看待 toB 与 toC",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzU1OTAyOTc=",
    "number": 115,
    "title": "【Q114】如何查看一个文件的 inode number",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk3ODc1Nw==",
      "body": "可以使用 `ls` 或者 `stat`\r\n\r\n``` bash\r\n$ stat hello.txt\r\n  File: ‘hello.txt’\r\n  Size: 30              Blocks: 8          IO Block: 4096   regular file\r\nDevice: fd01h/64769d    Inode: 917526      Links: 1\r\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\r\nAccess: 2019-12-10 16:15:55.253325208 +0800\r\nModify: 2019-12-10 16:15:52.740653330 +0800\r\nChange: 2019-12-10 16:15:52.742653069 +0800\r\n\r\n$ ls -i hello.txt\r\n917526 hello.txt\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2NTA0MDI=",
    "number": 116,
    "title": "【Q115】文件系统中 mtime 和 ctime 指什么，都有什么不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk4MzQ3Nw==",
      "body": "在 `linux` 中，\r\n\r\n+ `mtime`：`modified time` 指文件内容改变的时间戳\r\n+ `ctime`：`change time` 指文件属性改变的时间戳，属性包括 `mtime`。而在 windows 上，它表示的是 `creation time`\r\n\r\n所以 `ctime` 会比 `mtime` 要大一些，使用 `stat` 查看文件属性如下\r\n\r\n``` bash\r\n$ stat hello.txt\r\n  File: ‘hello.txt’\r\n  Size: 30              Blocks: 8          IO Block: 4096   regular file\r\nDevice: fd01h/64769d    Inode: 917526      Links: 1\r\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\r\nAccess: 2019-12-10 16:15:55.253325208 +0800\r\nModify: 2019-12-10 16:15:52.740653330 +0800\r\nChange: 2019-12-10 16:15:52.742653069 +0800\r\n Birth: -\r\n```\r\n\r\n而 http 服务选择 `Last_Modified` 时一般会选择 `mtime`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2NzAxMjE=",
    "number": 117,
    "title": "【Q116】http 服务中静态文件的 Last-Modified 是根据什么生成的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk5NzU5OA==",
      "body": "一般会选文件的 `mtime`，表示文件内容的修改时间\r\n\r\n`nginx` 也是这样处理的，源码见: [ngx_http_static_module.c](https://github.com/nginx/nginx/blob/4bf4650f2f10f7bbacfe7a33da744f18951d416d/src/http/modules/ngx_http_static_module.c#L217)\r\n\r\n``` c\r\n    r->headers_out.status = NGX_HTTP_OK;\r\n    r->headers_out.content_length_n = of.size;\r\n    r->headers_out.last_modified_time = of.mtime;\r\n```\r\n\r\n关于为什么使用 `mtime` 而非 `ctime`，可以参考 [#116](https://github.com/shfshanyue/Daily-Question/issues/117)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2ODYxNjY=",
    "number": 118,
    "title": "【Q117】既然 http 是无状态协议，那它是如何保持登录状态",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDAwMzA2Nw==",
      "body": "通过 cookie 或者 Authorization header 来传递凭证，在服务端进行认证",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU3ODY0ODM=",
    "number": 119,
    "title": "【Q118】有没有读过 koa 的源码，什么是洋葱模型呢",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzU3ODcwMDU=",
    "number": 120,
    "title": "【Q119】https 是如何保证报文安全的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODM4MDY4MA==",
      "body": "https主要解决三个安全问题：\r\n1. 内容隐私\r\n2. 防篡改\r\n3. 确认对方身份\r\n\r\nhttps并不是直接通过非对称加密传输过程，而是有握手过程，握手过程主要是和服务器做通讯，生成私有秘钥，最后通过该秘钥对称加密传输数据。还有验证证书的正确性。\r\n证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "wython",
        "url": "https://github.com/wython"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU4MTAyNTc=",
    "number": 121,
    "title": "【Q120】TCP 是如何保证可靠性的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDkwNDY3Nw==",
      "body": "ACK",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU4MTk4MDM=",
    "number": 122,
    "title": "【Q121】我们如何从 http 的报文中得知该服务使用的技术栈",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDEwMTEwMw==",
      "body": "一般有两个 response header，有时服务端为了隐蔽自己真实的技术栈会隐蔽这两个字段\r\n\r\n+ `X-Powerd-By`\r\n+ `Server`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzYxODgyMjQ=",
    "number": 123,
    "title": "【Q122】在发送 http 请求报文时，Host 是必要的吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDgwODY1NA==",
      "body": "是有必要的，因为我们不知道会途径会不会有代理出现， 如果直接到达服务器的话，服务器是可以通过路径知道资源在哪，但是如果通过代理的话，代理无法得知具体服务器是什么地址",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "Gloomysunday28",
        "url": "https://github.com/Gloomysunday28"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY3MzY1NTI=",
    "number": 124,
    "title": "【Q123】如何监控文件的变动",
    "body": "当一个文件或者一个目录下的文件有所变动时能够监控到。\r\n\r\n如一些前端和后端项目在开发环境下会根据项目目录变动而重启或者重新编译",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDkwNDYwMQ==",
      "body": "1. 在 node 中调用 API `fs.watch`\r\n1. 在 linux 中原理是 `inotify`，macos 中原理是 `FSEvents`，windows 中原理是 ` ReadDirectoryChangesW`\r\n1. 由于内核对文件监控更加细粒度，更加敏感，当每次修改文件时可能触发内核多次调用，需要防抖\r\n1. 注意软链接，读写权限等文件系统属性\r\n\r\n可参考文章 [How to Watch for Files Changes in Node.js](https://thisdavej.com/how-to-watch-for-files-changes-in-node-js/) 及 [精读《如何利用 Nodejs 监听文件夹》](https://github.com/dt-fe/weekly/blob/v2/059.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%20Nodejs%20%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%8B.md)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY4MDc0NDQ=",
    "number": 125,
    "title": "【Q124】如何保证内网服务的安全性",
    "body": "如 `gitlab CE` 经常暴露出重大漏洞，而它也只需要在公司内部使用。部署 `gitlab` 时我们如何保证它的安全性",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NDk2MTA5Nw==",
      "body": "basic auth，digest auth，ip whitelist，vpn",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY4MzU3MzA=",
    "number": 126,
    "title": "【Q125】docker 中如何为每个容器的 cpu/memory 设限，原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Mzc0MTgzNzQ=",
    "number": 127,
    "title": "【Q126】localhost:3000 与 localhost:5000 的 cookie 信息是否共享",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NTM1Mjk1Mg==",
      "body": "共享",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc1NDM2MzA=",
    "number": 128,
    "title": "【Q127】vpn 的原理是什么",
    "body": "当在公司工作时经常需要 vpn 用以连接公司内网，其原理是什么",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODMzMjQ2NQ==",
      "body": "正向代理",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "xinlanlan",
        "url": "https://github.com/xinlanlan"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc4ODYyMzI=",
    "number": 129,
    "title": "【Q128】构建镜像时，那几个指令会增加镜像层数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NTY5Njk1Nw==",
      "body": "`RUN`，`ADD`，`COPY`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc5MDczNTY=",
    "number": 130,
    "title": "【Q129】shell 中 ${} 与 $() 各是什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NTcxMjkwOQ==",
      "body": "+ `${}` 变量\r\n+ `$()` 命令",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzgxMjc4MDU=",
    "number": 131,
    "title": "【Q130】docker 如何隔离容器与宿主机的时间",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzgxMjkzODM=",
    "number": 132,
    "title": "【Q131】在 docker 的容器中，如何访问宿主机的 localhost",
    "body": "如在宿主机有一个 `mysql` 数据库，在容器中，如何连接数据库",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzgxMzEzMjg=",
    "number": 133,
    "title": "【Q132】如何在 docker 中运行 docker",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1MzgyNzc2Nzg=",
    "number": 134,
    "title": "【Q133】http 响应头中如果 content-type 为 application/octet-stream，则代表什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMDg3MA==",
      "body": "代表二进制流，一般用以下载文件",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1MzkxMDc4ODk=",
    "number": 135,
    "title": "【Q134】ssh 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1MjE1ODM3OQ==",
      "body": "搬运 [图解SSH原理](https://www.jianshu.com/p/33461b619d53)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "hedongxiaoshimei",
        "url": "https://github.com/hedongxiaoshimei"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzk0MjUwMzk=",
    "number": 136,
    "title": "【Q135】负载均衡有哪几种方式，它们的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2Njg0NzUzOQ==",
      "body": "TODO",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDAxMzI2OTY=",
    "number": 137,
    "title": "【Q136】http 向 https 做重定向应该使用哪个状态码",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMTc1Nw==",
      "body": "一般用作 `301` 的较为多，但是也有使用 `302`，如果开启了 `HSTS` 则会使用 `307`\r\n\r\n如知乎使用了 302，淘宝使用了 301\r\n\r\n``` bash\r\n$ curl --head www.zhihu.com\r\nHTTP/1.1 302 Found\r\nDate: Tue, 24 Dec 2019 00:13:54 GMT\r\nContent-Length: 22\r\nConnection: keep-alive\r\nServer: NWS_TCloud_IPV6\r\nLocation: https://www.zhihu.com/\r\nX-NWS-LOG-UUID: 0e28d9a1-6aeb-42cd-9f6b-00bd6cf11500\r\n\r\n$ curl --head www.taobao.com\r\nHTTP/1.1 301 Moved Permanently\r\nServer: Tengine\r\nDate: Tue, 24 Dec 2019 00:13:58 GMT\r\nContent-Type: text/html\r\nContent-Length: 278\r\nConnection: keep-alive\r\nLocation: https://www.taobao.com/\r\nVia: cache20.cn1480[,0]\r\nTiming-Allow-Origin: *\r\nEagleId: 6f3f38a815771464380412555e\r\n\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA4MTY1NDQ=",
    "number": 138,
    "title": "【Q137】js 代码压缩的原理是什么",
    "body": "我们知道 `javascript` 代码经压缩 (uglify) 后，可以使体积变得更小，那它代码压缩的原理是什么。\r\n\r\n如果你来做这么一个功能的话，你会怎么去压缩一段 `js` 代码的体积",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NzgxOTE4Ng==",
      "body": "https://github.com/mishoo/UglifyJS2",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA5NjUwNTk=",
    "number": 139,
    "title": "【Q138】一个守护进程的创建步骤是什么，如何用 C 语言创建",
    "body": "#50 ",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDA5NzU5MDg=",
    "number": 140,
    "title": "【Q139】在 Node 应用中如何利用多核心CPU的优势",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NzkyNDQyMQ==",
      "body": "使用 `cluster` 模块\r\n\r\n[Node 中 cluster 的原理是什么](https://github.com/shfshanyue/Daily-Question/issues/141)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA5ODQ0NDI=",
    "number": 141,
    "title": "【Q140】Node 中 cluster 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2NzkyMzY1NA==",
      "body": "1. `fork` 子进程\r\n1. `Load Balance`\r\n1. 多进程共享端口\r\n\r\n## 相关文章\r\n\r\n+ [Node 官方文档: cluster](https://nodejs.org/api/cluster.html)\r\n+ [深入浅出 node cluster](https://juejin.im/post/5c87760fe51d4507534c88e5)\r\n+ [Node.js进阶：cluster模块深入剖析](https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/cluster.md)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDEzMjg1MTI=",
    "number": 142,
    "title": "【Q141】http 响应头中的 Date 与 Last-Modified 有什么不同，网站部署时需要注意什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODE4MjMzNw==",
      "body": "+ `Date`: 报文在源服务器的产生时间，由此可查看报文已缓存了多久时间\r\n+ `Last-Modified`: 源服务器上资源的上次修改时间\r\n\r\n`LM-Factor` 与它俩有关。\r\n\r\n简而言之，一个静态资源没有设置 `Cache-Control` 时会以这两个响应头来设置强制缓存时间：`(Date - LastModified) * n`，而非直接进行协商缓存。在涉及到 CDN 时，表现更为明显，体现在更新代码部署后，界面没有更新。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDE0MjcyMzg=",
    "number": 143,
    "title": "【Q142】react hooks 中如何模拟 componentDidMount",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODg1MDAwNw==",
      "body": "在 `useEffect`，把第二个参数即依赖的状态，设置为 `[]`\r\n \r\n``` js\r\nuseEffect(callback, [])\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDE1NzE2NTk=",
    "number": 144,
    "title": "【Q143】docker-compose 部署 docker 时，如何把宿主机的环境变量注入到容器中",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
        "name": "docker"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDE5Mzc1MTU=",
    "number": 145,
    "title": "【Q144】http 1.1 中的 keep-alive 有什么作用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMDUxMw==",
      "body": "在 `http 1.1` 中，在响应头中设置 `keep-alive` 可以在一个 TCP 连接上发送多个 http 请求\r\n\r\n1. 避免了重开 TCP 连接的开销\r\n1. 避免了刷新时重新建立 SSL 连接的开销\r\n1. 避免了QPS过大时，服务器的连接数过大\r\n\r\n在服务器端使用响应头开启 `keep-alive`\r\n\r\n``` bash\r\nConnection: Keep-Alive\r\nKeep-Alive: timeout=5, max=1000\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDIxMzQ2MTU=",
    "number": 146,
    "title": "【Q145】如何判断端口是否可达",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODc1MjAzMA==",
      "body": "使用 `nc`，`-z` 指测试接口连通性\r\n\r\n``` bash\r\nnc -vz localhost 443\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDIyMjk1OTE=",
    "number": 147,
    "title": "【Q146】如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2ODgxNzY1Mw==",
      "body": "不可以，created/componentWillMount 时，还未挂载，代码仍然在服务器中执行，此时没有浏览器环境，因此此时访问 localStorage 将会报错",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI1NDY2MzM=",
    "number": 148,
    "title": "【Q147】当在浏览器中看到某资源使用了 http2 后，使用 curl 为什么看到的仍是 http 1.1",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMTM4MzY4Mg==",
      "body": "当前 curl 的版本及支持的协议以及功能特性没有支持 HTTP2",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "vczx1994",
        "url": "https://github.com/vczx1994"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI3ODkxODU=",
    "number": 149,
    "title": "【Q148】关于 JSON，以下代码输出什么",
    "body": "``` js\r\nconst obj = {\r\n  a: 3,\r\n  b: 4,\r\n  c: null,\r\n  d: undefined,\r\n  get e () {}\r\n}\r\n\r\nconsole.log(JSON.stringify(obj))\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTIxNzAyNg==",
      "body": "> ``` js\r\n> const obj = {\r\n>   a: 3,\r\n>   b: 4,\r\n>   c: null,\r\n>   d: undefined,\r\n>   get e () {}\r\n> }\r\n> ```\r\n> \r\n> console.log(JSON.stringify(obj))\r\n>\r\n> 输出什么？\r\n\r\n``` js\r\n{\"a\":3,\"b\":4,\"c\":null}\r\n```\r\n\r\n对其中的 `undefined`，`function` 将在 `JSON.stringify` 时会忽略掉",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI3OTEzMzg=",
    "number": 150,
    "title": "【Q149】什么是队首阻塞，如何解决，原理如何",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDMxMzgwMDQ=",
    "number": 151,
    "title": "【Q150】redis 中 zset 是什么，用作什么应用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTQxMjcyNQ==",
      "body": "`SortedSet`，有序集合，一般可以有两种用途\r\n\r\n1. 排行榜，TOP N 之类\r\n1. 优先级消息队列",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDM3MDQxMDM=",
    "number": 152,
    "title": "【Q151】react hooks 如何替代或部分替代 redux 功能",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU2OTcwNDI4MQ==",
      "body": "我们把全局store分为两块\r\n\r\n1. 从服务器端来，如各种 `model`，此时可以使用 `swr` 直接替代。或者封装一个 `useModel`，如 `useUser`，`usePermission`\r\n1. 客户端全局 store，此时可以使用 `useReducer` 和 `useContext` 来替代",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDM3MDQ5NTA=",
    "number": 153,
    "title": "【Q152】如何实现一个 react hook，你有没有自己写过一个",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MDUzMzQzNg==",
      "body": "各种优秀实现=》https://github.com/streamich/react-use",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "into-piece",
        "url": "https://github.com/into-piece"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0MzI2MjM=",
    "number": 154,
    "title": "【Q153】权限设计中的 RABC 是指什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcwMTc0MTg3Mw==",
      "body": "RBAC: Role-Based Access Control?",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "e10101",
        "url": "https://github.com/e10101"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0NTk0MjA=",
    "number": 155,
    "title": "【Q154】在 react/vue 中数组是否可以以在数组中的次序为 key",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MDUzMjIwMg==",
      "body": "不可，key应为唯一标示，在数组变更时插入或删除后，index无法确保始终指向对应的序列",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "into-piece",
        "url": "https://github.com/into-piece"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0ODE3NjM=",
    "number": 156,
    "title": "【Q155】当服务升级或者回退时，如何保证流量平滑切换",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDQ1NDE5Mjc=",
    "number": 157,
    "title": "【Q156】如何进行代码质量检测",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MDE4Nzc0NA==",
      "body": "圈复杂度(Cyclomatic complexity)描写了代码的复杂度，可以理解为覆盖代码所有场景所需要的最少测试用例数量。CC 越高，代码则越不好维护\r\n\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ1NTcxMDg=",
    "number": 158,
    "title": "【Q157】如何管理生产环境多个数据库的配置，如何快速连接",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDUyODExMzI=",
    "number": 159,
    "title": "【Q158】数据库 postgres 与 mysql 相比有哪些优劣",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzQ2NDc=",
    "number": 160,
    "title": "【Q159】什么是 CSRF 攻击",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMzgyMTQyOA==",
      "body": "跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。\r\n\r\n来源：[维基百科](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "DoubleRayWang",
        "url": "https://github.com/DoubleRayWang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzUwNDI=",
    "number": 161,
    "title": "【Q160】如何设置一个 cookie",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMjgxMjk3MQ==",
      "body": "HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。\r\n\r\n服务端是通过setCookie的响应头来设置cookie的，要设置多个cookie时，得多写几个setCookie。服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个Set-Cookie字段。\r\n\r\n前端使用document.cookie属性来读写当前网页的 Cookie。写入的时候，Cookie 的值必须写成key=value的形式。\r\n\r\nCookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。\r\n参考资料：\r\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)\r\n[把cookie聊清楚](https://juejin.im/post/59d1f59bf265da06700b0934)\r\n[阮一峰JavaScript教程](https://javascript.ruanyifeng.com/bom/cookie.html)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "SageSanyue",
        "url": "https://github.com/SageSanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzUwNjU=",
    "number": 162,
    "title": "【Q161】如何删除一个 cookie",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NDgxMjkzOQ==",
      "body": "通过把该 `cookie` 的过期时间改为过去时即可删除成功，具体操作的话可以通过操作两个字段来完成\r\n\r\n1. `max-age`: 将要过期的最大秒数，设置为 `-1` 即可删除\r\n1. `expires`: 将要过期的绝对时间，存储到 `cookies` 中需要通过 `date.toUTCString()` 处理，设置为过期时间即可删除\r\n\r\n很明显，`max-age` 更为简单\r\n\r\n``` js\r\n// max-age 设置为 -1 即可成功\r\ndocument.cookie = 'a=3; max-age=-1'\r\n```\r\n\r\n``` js\r\n> document.cookie\r\n< \"\"\r\n\r\n> document.cookie = 'a=3'\r\n< \"a=3\"\r\n\r\n> document.cookie\r\n< \"a=3\"\r\n\r\n// 把该字段的 max-age 设置为 -1\r\n> document.cookie = 'a=3; max-age=-1'\r\n< \"a=3; max-age=-1\"\r\n\r\n// 删除成功\r\n> document.cookie\r\n< \"\"\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDU0MTk0OTE=",
    "number": 163,
    "title": "【Q162】如何禁止服务器被 ping",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY5MzM4NTQ3MA==",
      "body": "\r\n> echo \"1\" > /proc/sys/net/ipv4/icmp_echo_ignore_all\r\n\r\n\r\n[How do I disable ping responses from my system?\r\n](https://access.redhat.com/articles/7134#:~:text=To%20configure%20a%20Red%20Hat,command%20as%20the%20root%20user.&text=To%20make%20the%20changes%20persistent,to%20ICMP%20(ping)%20net.)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "iSenninha",
        "url": "https://github.com/iSenninha"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDU3MDExMDM=",
    "number": 164,
    "title": "【Q163】如何创建一个线程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MjUzNTY3NQ==",
      "body": "创建一个最简单的线程\r\n\r\n``` c\r\n#include <pthread.h>\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nvoid *thread_function(void *arg) {\r\n  printf(\"hello, world\\n\");\r\n  sleep(10);\r\n}\r\n\r\nint main() {\r\n  pthread_t thread;\r\n\r\n  pthread_create(&thread, NULL, thread_function, NULL);\r\n  pthread_join(thread, NULL);\r\n}\r\n```\r\n\r\n执行它\r\n\r\n``` bash\r\n$ gcc thread.c -std=c99 -lpthread && ./a.out\r\nhello, world\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc0Mzk3ODI=",
    "number": 165,
    "title": "【Q164】React 中 fiber 是用来做什么的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMDczODQ3NA==",
      "body": "因为JavaScript单线程的特点，每个同步任务不能耗时太长，不然就会让程序不会对其他输入作出相应，React的更新过程就是犯了这个禁忌，而React Fiber就是要改变现状。\r\n而可以通过分片来破解JavaScript中同步操作时间过长的问题。\r\n\r\n把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。\r\n\r\nReact Fiber把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。\r\n\r\n维护每一个分片的数据结构，就是Fiber。",
      "reactions": {
        "totalCount": 2
      },
      "author": {
        "login": "yuzeyang97",
        "url": "https://github.com/yuzeyang97"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc1MTMwODM=",
    "number": 166,
    "title": "【Q165】什么是公有云，私有云，混合云以及多重云",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDc1MzA5OTA=",
    "number": 167,
    "title": "【Q166】在C语言中，void * 是什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxNTMzMTM0OA==",
      "body": "`void` 指无类型，常用在函数前，表示什么也不用返回。\r\n\r\n`*` 代表一个指针，如 `int *p` 代表指针 p 指向一个整型，`char *s` 代表指针 s 指向一个字符串的首地址。\r\n\r\n而 `void *` 代表一个可能指向任何类型的指针，如下代码所示：\r\n\r\n``` c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n  void *p;\r\n\r\n  // 使用它装一个整数\r\n  int a = 3;\r\n  p = &a;\r\n  printf(\"%d\", *(int *)p);\r\n\r\n  // 使用它装一个字符串\r\n  char s[] = \"hello, world\";\r\n  p = s;\r\n  printf(\"%s\", p);\r\n  return 0;\r\n}\r\n```\r\n\r\n## 相关问题\r\n\r\n+ [【Q433】在C语言中，void 是什么意思](https://github.com/shfshanyue/Daily-Question/issues/440)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg0MTM1MTQ=",
    "number": 168,
    "title": "【Q167】每个指针所占的存储空间是多少",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MzMwNDg5MQ==",
      "body": "与字长有关。如果是64位系统，则占八个字节，32位系统，则占四个字节。可以用 `sizeof` 测试\r\n\r\n``` c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n  int *p;\r\n\r\n  printf(\"size: %d\", sizeof(p));\r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg3MTA3OTM=",
    "number": 169,
    "title": "【Q168】在 js 中如何把类数组转化为数组",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MzY3MTY0Mg==",
      "body": "首先，什么是类数组(Array Like)？\r\n\r\n**一个简单的定义，如果一个对象有 `length` 属性值，则它就是类数组**\r\n\r\n那常见的类数组有哪些呢？\r\n\r\n这在 DOM 中甚为常见，如各种元素检索 API 返回的都是类数组，如 `document.getElementsByTagName`，`document.querySelectorAll` 等等。除了 DOM API 中，常见的 `function` 中的 `arguments` 也是类数组\r\n\r\n那如何把类数组转化为数组呢？这是类数组操作时一个典型的场景，也是一个典型的面试题\r\n\r\n以下我们将以 `{ length: 3 }` 来指代类数组，来作为演示\r\n\r\n<!--more-->\r\n\r\n## ES6+\r\n\r\n`ES6` 中有现成的 API：`Array.from`，极为简单\r\n\r\n``` js\r\n// [undefined, undefined, undefined]\r\nArray.from({ length: 3 })\r\n```\r\n\r\n除了 `Array.from` 还有更简单的运算符 `...` 扩展运算符，不过它只能作用于 `iterable` 对象，即拥有 `Symbol(Symbol.iterator)` 属性值\r\n\r\n拥有 `Symbol(Symbol.iterator)` 属性值，意味着可以使用 `for of` 来循环迭代\r\n\r\n``` js\r\n// 适用于 iterable 对象\r\n[...document.querySelectorAll('div')]\r\n```\r\n\r\n但是严格意义上来说，它不能把类数组转化为数组，如 `{ length: 3 }`。它将会抛出异常\r\n\r\n``` js\r\n// Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))\r\n[...{length: 3}]\r\n```\r\n\r\n## ES5\r\n\r\n在此之前，我们先不使用 `{ length: 3 }`，使用以下数据来代表类数组\r\n\r\n``` js\r\nconst arrayLike = {\r\n  0: 3,\r\n  1: 4,\r\n  2: 5,\r\n  length: 3\r\n}\r\n```\r\n\r\n在 `ES5` 中可以借用 `Array API` 通过 `call/apply` 改变 `this` 或者 `arguments` 来完成转化。\r\n\r\n最常见的转换是 `Array.prototype.slice`\r\n\r\n``` js\r\nArray.prototype.slice.call(arrayLike)\r\n```\r\n\r\n**当然由于借用 `Array API`，一切以数组为输入，并以数组为输出的 API 都可以来做数组转换，如**\r\n\r\n+ `Array` (借用 arguments)\r\n+ `Array.prototype.concat` (借用 arguments)\r\n+ `Array.prototype.slice` (借用 this)\r\n+ `Array.prototype.map` (借用 this)\r\n+ `Array.prototype.filter` (借用 this)\r\n\r\n``` js\r\nArray.apply(null, arrayLike)\r\nArray.prototype.concat.apply([], arrayLike)\r\nArray.prototype.slice.call(arrayLike)\r\nArray.prototype.map.call(arrayLike, x => x)\r\nArray.prototype.filter.call(arrayLike, x => 1)\r\n```\r\n\r\n此时一切正常，但是忘了一个特例，稀疏数组。在此之前，先做一个题，以下代码输出多少\r\n\r\n``` js\r\n// 该代码输出多少\r\nArray(100).map(x => 1)\r\n```\r\n\r\n> 参考 [Array(100).map(x => 1) 结果是多少](https://github.com/shfshanyue/Daily-Question/issues/170)\r\n\r\n## 稀疏数组 (sparse array)\r\n\r\n使用 `Array(n)` 将会创建一个稀疏数组，为了节省空间，稀疏数组内含非真实元素，在控制台上将以 `empty` 显示，如下所示\r\n\r\n`[,,,]` 与 `Array(3)` 都将返回稀疏数组\r\n\r\n``` js\r\n> [,,,]\r\n[empty × 3]\r\n> Array(3)\r\n[empty × 3]\r\n```\r\n\r\n当类数组为 `{ length: 3 }` 时，一切将类数组做为 `this` 的方法将都返回稀疏数组，而将类数组做为 `arguments` 的方法将都返回密集数组\r\n\r\n## 总结\r\n\r\n由上总结，把类数组转化成数组最靠谱的方式是以下三个\r\n\r\n``` js\r\nArray.from(arrayLike)\r\nArray.apply(null, arrayLike)\r\nArray.prototype.concat.apply([], arrayLike)\r\n```\r\n\r\n以下几种方式需要考虑稀疏数组的转化\r\n\r\n``` js\r\nArray.prototype.filter.call(divs, x => 1)\r\nArray.prototype.map.call(arrayLike, x => x)\r\nArray.prototype.filter.call(arrayLike, x => 1)\r\n```\r\n\r\n以下方法要注意是否是 `iterable object`\r\n\r\n``` js\r\n[...arrayLike]\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg3MzAxNjc=",
    "number": 170,
    "title": "【Q169】Array(100).map(x => 1) 结果是多少",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3Mzk2MTEwNQ==",
      "body": "> 那如何生成100个元素为1的数组呢？\r\n\r\n```ts\r\nArray(100).fill(1)\r\n```",
      "reactions": {
        "totalCount": 2
      },
      "author": {
        "login": "Chersquwn",
        "url": "https://github.com/Chersquwn"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg4MzUzMDY=",
    "number": 171,
    "title": "【Q170】什么是文件描述符 (file descriptor)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3MzU5OTE0MA==",
      "body": "`fd` 在内核中通常表示为非负整数，当进程新建或者打开文件时，内核将会返回一个文件描述符，使用它可以用来读写文件。\r\n\r\n另外，新建 `socket` 时也会产生一个文件描述符。\r\n\r\n另外，有三个特殊的文件描述符，用以表示标准输入，标准输出及标准错误\r\n\r\n+ `STDIN_FILENO`: 0\r\n+ `STDOUT_FILENO`: 1\r\n+ `STDERR_FILENO`: 2",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDkzNTkzNjc=",
    "number": 172,
    "title": "【Q171】在服务器内如何得知自己的公网IP",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3NDAyMzI2NQ==",
      "body": "有现成的公网IP服务提供，根据 TCP 连接获得真实 IP 地址\r\n\r\n``` bash\r\n$ curl ifconfig.me\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk0MTQ3MjE=",
    "number": 173,
    "title": "【Q172】C语言中 printf 与 puts 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3NDA2NjU1Ng==",
      "body": "```c\r\n// 支持各种格式\r\nint printf(const char *__restrict__ __format, ...);\r\n\r\n// 只支持字符串输出到 stdout，适用于只有字符串时\r\nint puts(const char *__s);\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk0NTk5NDI=",
    "number": 174,
    "title": "【Q173】简述 UDP socket 建立的过程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3NDA5OTY3MQ==",
      "body": "一图胜千言\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/72334798-e3365700-36f8-11ea-9bd8-1bfd59118c01.png)\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk1MjUwMzc=",
    "number": 175,
    "title": "【Q174】TCP 三次握手发生在 socket 建立的哪一步",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDk1MjUzNDA=",
    "number": 176,
    "title": "【Q175】如何使用 css 写一个魔方",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDk1NzgyNjA=",
    "number": 177,
    "title": "【Q176】如何在数组中找出三个数之和为N",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NDk2MjY5NjQ=",
    "number": 178,
    "title": "【Q177】如何在 url 中传递数组",
    "body": "可以参考 [arrays in query params](https://medium.com/raml-api/arrays-in-query-params-33189628fa68)",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTAwMjQ0NjM=",
    "number": 179,
    "title": "【Q178】如何使用 css 写一个有 3D 效果的立方体",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NjQ0NDE0Mw==",
      "body": "`<div class=\"warp\">\r\n\t<div class=\"box box1\">1</div>\r\n    <div class=\"box box2\">2</div>\r\n    <div class=\"box box3\">3</div>\r\n    <div class=\"box box4\">4</div>\r\n    <div class=\"box box5\">5</div>\r\n    <div class=\"box box6\">6</div>\r\n</div>`\r\n`* {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n}\r\n\r\nbody {\r\n\tperspective: none;\r\n\tperspective-origin: 50% 50%;\r\n}\r\n\r\n.warp {\r\n\twidth: 500px;\r\n\theight: 500px;\r\n\tmargin: 100px auto;\r\n\t\r\n\tposition: relative;\r\n\t\r\n\ttransform-style: preserve-3d;\r\n\t\r\n\ttransform: rotateX(45deg) rotateY(45deg);\r\n\t\r\n\tanimation: play 5s linear infinite;\r\n}\r\n\r\n.box {\r\n\twidth: 200px;\r\n\theight: 200px;\r\n\tborder: 2px solid #ccc;\r\n\t\r\n\ttext-align: center;\r\n\tline-height: 200px;\r\n\tfont-size: 150px;\r\n\tfont-weight: bold;\r\n\tcolor: #fff;\r\n\t\r\n\tposition: absolute;\r\n\ttop: 150px;\r\n\tleft: 150px;\r\n}\r\n\r\n.box1 {\r\n\tbackground: rgba(135,135,135,.3);\r\n\ttransform: rotateY(90deg) translateZ(100px);\r\n}\r\n\r\n.box2 {\r\n\tbackground: rgba(135,0,255,.3);\r\n\ttransform: rotateY(90deg) translateZ(-100px);\r\n}\r\n\r\n.box3 {\r\n\tbackground: rgba(255,125,125,.3);\r\n\ttransform: rotateX(90deg) translateZ(-100px);\r\n}\r\n\r\n.box4 {\r\n\tbackground: rgba(125,255,125,.3);\r\n\ttransform: rotateX(90deg) translateZ(100px);\r\n}\r\n\r\n.box5 {\r\n\tbackground: rgba(30,150,189,.3);\r\n\ttransform: translateZ(100px);\r\n}\r\n\r\n.box6 {\r\n\tbackground: rgba(169,150,189,.3);\r\n\ttransform: translateZ(-100px);\r\n}\r\n\r\n@keyframes play {\r\n\tfrom{ transform: rotateX(0) rotateY(0) rotateZ(0);}\r\n\tto {transform: rotateX(360deg) rotateY(180deg) rotateZ(90deg);}\r\n}`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "lihan1k",
        "url": "https://github.com/lihan1k"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTAxNzM3ODM=",
    "number": 180,
    "title": "【Q179】ssh 如何设置 IP whiteList",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTAyNDUxMTk=",
    "number": 181,
    "title": "【Q180】当执行 SQL 语句 select * from user where id = 1 时发什么了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTA4NjI4NDc=",
    "number": 182,
    "title": "【Q181】如何用一行代码实现 compose 函数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MTU2NDM1NA==",
      "body": "```\r\nfunction compose() {\r\n\r\n  let fns = [...arguments];\r\n\r\n  return function() {\r\n    let args = [...arguments];\r\n    let result = fns.reduce((ret, fn) => {\r\n      ret = fn.apply(this, ret);\r\n      return Array.isArray(ret) ? ret : [ret];\r\n    }, args);\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\nlet toUpperCase = (x) => x.toUpperCase();\r\nlet exclaim = (x) => x + '!';\r\nlet shout = compose(toUpperCase,exclaim);\r\nlet str = shout('hello world');\r\nconsole.log(str);\r\n```\r\n\r\n第一次试着写，简单查了一下compose是什么意思，竟然拼凑出来了。请各位指正。  :smile:",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "LRQLRQ",
        "url": "https://github.com/LRQLRQ"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTEyNzc0MDg=",
    "number": 183,
    "title": "【Q182】简述 TCP 的四次挥手，三次挥手可以吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3NTU3MjAwNQ==",
      "body": "第一次挥手 客户端 发送 fin 给服务端 \r\n第二次回收 服务端 发送 ack 给客户端\r\n中间服务端 可能还有数据传输\r\n第三次挥手 服务端 发送 fin 给客户端\r\n第四次挥手 客户端 发送 ack 给 客户端\r\n上述四个挥手 分别 类比 两人再打电话\r\nA对B说 我说完了\r\nB对A说 我知道了\r\n中间 b还有话说\r\nB再对A说 我也说完了\r\nA再对B说 我知道了\r\n双方挂断电话\r\n\r\n如果只有两次 即A对B说我说完了 而没有ack, A不确定B是否知道\"A我说完了\"这句话B听到没有\r\n同理,第三次挥手 B对A说我说完了, 还没等A回答我知道了就挂断,有可能A不知道B已经说完.\r\n\r\ntcp协议之所以可靠 就是由于 三次握手四次挥手 建立的连接, 以及ack回执机制,\r\n如果传输过程中连接断开 又会重新三次握手建立连接, 如果一直没收到ack, 发送方会一直发送相同的消息,等待另一方发ack回执回来",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "manondidi",
        "url": "https://github.com/manondidi"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTEyOTEwMjA=",
    "number": 184,
    "title": "【Q183】tcp 中 time_wait 堆积过多会有什么问题，为什么它超时时间这么长",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTE3NzQ4OTE=",
    "number": 185,
    "title": "【Q184】有没有使用过 css variable，它解决了哪些问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NTY3ODE3MQ==",
      "body": "css变量减少样式重复定义，比如同一个颜色值要在多个地方重复使用，以前通过less和sass预处理做到，现在css变量也可以做到，方便维护，提高可读性\r\n```\r\n:root{\r\n  --bgcolor: blue;\r\n  --color: red;\r\n}\r\np {\r\n  color: var(--color);\r\n}\r\ndiv {\r\n  backgroung-color: var(--bgcolor);\r\n  color: var(--color)\r\n}\r\n```\r\n在媒体查询中使用，精简代码，减少冗余\r\n```\r\n.box {\r\n  --base-size: 10;\r\n  width: calc(var(--base-size)* 10px);\r\n  height: clac(var(--base-size)* 5px);\r\n  padding:calc(var(--base-size) * 1px);\r\n}\r\n@media screen and (min-width: 1480px) {\r\n  .box{\r\n    --base-size: 8;\r\n  }\r\n}\r\n```\r\n方便在js中使用\r\n```\r\n// 设置变量\r\ndocument.getElementById(\"box\").style.setPropertyValue('--color', 'pink')\r\n// 读取变量\r\ndoucment.getElementById('box').style.getPropertyValue('--color').trim()    //pink\r\n// 删除变量\r\ndocument.getElementById('box').style.removeProperty('--color')\r\n```",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "Cicelychen",
        "url": "https://github.com/Cicelychen"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTE3ODAwOTM=",
    "number": 186,
    "title": "【Q185】谈谈你对 styled-component 的看法",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTE5MTYyNTY=",
    "number": 187,
    "title": "【Q186】写一个关于全排列，全组合的函数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU3NjAwMTMxOA==",
      "body": "## `Arragement`\r\n\r\n## `Combination`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTIyOTkyODU=",
    "number": 188,
    "title": "【Q187】当编辑 graphql 的 query 时，如何在编辑器中自动补全",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
        "name": "graphql"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTUwNTI0NjY=",
    "number": 189,
    "title": "【Q188】大数乘法和大数加法",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NTU0Mjk3NTE=",
    "number": 190,
    "title": "【Q189】performance API 中什么指标可以衡量首屏时间",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczNjU2ODYxOA==",
      "body": "window.performance.timing,详细的可以看下这篇文章[前端性能优化衡量指标](https://serverless-action.com/fontend/fe-optimization/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87.html#performance-api)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "nieyao",
        "url": "https://github.com/nieyao"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU1MjcyMDY=",
    "number": 191,
    "title": "【Q190】使用 CSS 如何画一个三角形",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMTQ0NDc2OA==",
      "body": "`\r\n.triangle {\r\n    width: 0px;\r\n    height: 0px;\r\n    border: 100px solid;\r\n    border-color: transparent transparent rgba(134, 241, 143,1) transparent;\r\n}\r\n`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "Sumarina",
        "url": "https://github.com/Sumarina"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU1NDIxNjg=",
    "number": 192,
    "title": "【Q191】什么是 Open Graph 协议，用来做什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NTI0NjQwNQ==",
      "body": "Open Graph 协议可以让任何一个网页集成到社交图谱中。例如，facebook就是一种社交图谱(social graph)。\r\n一旦一个网页按照该协议进行集成，这个网页就像是社交图谱的一个节点，例如，你的网页集成了open graph协议，\r\n按照协议加入了网页的标题，描述以及图片信息等等，那么你在facebook中分享这个网页的时候，facebook就会按照\r\n你定义的内容来展示这个网页。\r\n\r\n这个协议其实很简单，主要是通过在html中加入一些元数据（meta）标签来实现，例如\r\n在head中加入meta标签，property是以og(open graph)开头, 后面跟着具体属性，content里面是属性的值，\r\n下面这段描述的就是一个类型为 video.movie，标题为 The rock，以及url和图片信息。这个例子就可以当做是\r\n为 https://www.imdb.com/title/tt0117500/ 实现了Open Graph协议、\r\n\r\n```\r\n<html prefix=\"og: http://ogp.me/ns#\">\r\n<head>\r\n<title>The Rock (1996)</title>\r\n<meta property=\"og:title\" content=\"The Rock\" />\r\n<meta property=\"og:type\" content=\"video.movie\" />\r\n<meta property=\"og:url\" content=\"http://www.imdb.com/title/tt0117500/\" />\r\n<meta property=\"og:image\" content=\"http://ia.media-imdb.com/images/rock.jpg\" />\r\n...\r\n</head>\r\n...\r\n</html>\r\n```\r\n结论：\r\n这个协议主要是Facebook提出来的，为了更好的展示用户分享的网页的内容，实现这个协议，有助于SEO优化，告诉google该网页有哪些内容，以及关键词等。\r\n\r\n可以快速实现Open Graph协议的工具有：\r\nWordpress的SEO plugin\r\n使用Facebook的Facebook Page功能\r\n\r\n \r\nReference:\r\n1. The Open Graph Protocol https://ogp.me/\r\n2. Open Graph Protocol for Facebook Explained with Examples  https://www.optimizesmart.com/how-to-use-open-graph-protocol/",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "grace-shi",
        "url": "https://github.com/grace-shi"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NTg1MjgwMzI=",
    "number": 193,
    "title": "【Q192】简述你们前端项目中资源的缓存配置策略",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NjAyNzUyNzM=",
    "number": 194,
    "title": "【Q193】如何加速 npm install",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NzQyOTg5Mw==",
      "body": "换成taobao源?",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "CaicoLeung",
        "url": "https://github.com/CaicoLeung"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjAzMjk5NTM=",
    "number": 195,
    "title": "【Q194】npm i 与 npm ci 的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MTcwOTcwOQ==",
      "body": "npm ci  (6.0版本以上)\r\n   1。会删除项目中的 `node_modules` 文件夹；\r\n   2.  会依照项目中的`package.json` 来安装确切版本的依赖项；\r\n   3. 不像 npm install, `npm ci` 不会修改你的 `package-lock.json` 但是它确实期望你的项目中有一个 - package-lock.json 文件 - 如果你没有这个文件， npm ci 将不起作用，此时必须使用 npm install",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "fariellany",
        "url": "https://github.com/fariellany"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjA0NjEwNzY=",
    "number": 196,
    "title": "【Q195】package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NjI1OTIxMjI=",
    "number": 197,
    "title": "【Q196】前端中遇到过处理二进制的场景吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMzg2NDA4MA==",
      "body": "[JavaScript二进制数据处理](http://coinfaces.me/posts/handling-binary-data-using-javascript/)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "DoubleRayWang",
        "url": "https://github.com/DoubleRayWang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjI2NDMyNTU=",
    "number": 198,
    "title": "【Q197】什么是 TypedArray",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NjMxNzkxMDU=",
    "number": 199,
    "title": "【Q198】如何实现类似 lodash.get 函数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NjQ0Mzk3Mzk=",
    "number": 200,
    "title": "【Q199】如何判断文件中的换行符是 LF 还是 CRLF",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Njg0MDM2MzU=",
    "number": 201,
    "title": "【Q200】前端如何进行多分支部署",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1Njg2NTM0NTY=",
    "number": 202,
    "title": "【Q201】js 中什么是可选链",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU4OTQzODU3Mw==",
      "body": "`?.` 操作符，可以嵌套获取对象的属性值。通过获取对象属性获得的值可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。\r\n\r\n``` javascript\r\nconst o = {}\r\n\r\n// 添加可选链之前\r\no && o.a && o.a.b && o.a.b.c && o.a.b.c.d\r\n\r\n// 添加可选链之后\r\no?.a?.b?.c?.d\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Njg5NTUzMjc=",
    "number": 203,
    "title": "【Q202】如何实现一个深拷贝",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyODc3MTU1NQ==",
      "body": "```js\r\nconst oldJson = { a: 1 }\r\nconst newJson = JSON.parse(JSON.stringify(oldJson))\r\noldJson.a = 2\r\nconsole.log(oldJson) // {a: 2}\r\nconsole.log(newJson) // {a: 1}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "coderwuhe",
        "url": "https://github.com/coderwuhe"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NjkzMjAxNTM=",
    "number": 204,
    "title": "【Q203】对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗？",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNTQyOTMwMw==",
      "body": "如果开启了tree shaking应该不会打包。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "blank121",
        "url": "https://github.com/blank121"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Njk4NzQ5Nzg=",
    "number": 205,
    "title": "【Q204】Node 中如何判断一个路径是文件还是文件夹",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMTI5MTU0Ng==",
      "body": "const  statInfo = fs.lstatSync(\"./xx\").\r\nstatInfo.isDirectory()",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "PlutoCA",
        "url": "https://github.com/PlutoCA"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Njk5ODMyNTU=",
    "number": 206,
    "title": "【Q205】Code Splitting 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
        "name": "webpack"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5MTMzODg1MA==",
      "body": "https://www.toutiao.com/i6790221102615364108/",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "yt253284494",
        "url": "https://github.com/yt253284494"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzE0NjE5MTU=",
    "number": 207,
    "title": "【Q206】no-cache 与 no-store 的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5OTE5MjU5MA==",
      "body": "no-cache 可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用 \r\nno-store 是禁用缓冲，本地和代理服务器都不缓冲，每次都从服务器获取",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "lijiayi01",
        "url": "https://github.com/lijiayi01"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzMyNDkxODA=",
    "number": 208,
    "title": "【Q207】什么是隔离级",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzM1Njk3MTI=",
    "number": 209,
    "title": "【Q208】在 postgres 中如何查看慢查询语句",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzM5ODUxMzc=",
    "number": 210,
    "title": "【Q209】如何得知一条 SQL 执行的时长？",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzQ2NTEyMDc=",
    "number": 211,
    "title": "【Q210】如何判断当前环境时移动端还是PC端",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5Mzk1MjgzNg==",
      "body": "判断 `navigator.userAgent`，对于 Android/iPhone 可以匹配以下正则\r\n\r\n``` js\r\nconst appleIphone = /iPhone/i;\r\nconst appleIpod = /iPod/i;\r\nconst appleTablet = /iPad/i;\r\nconst androidPhone = /\\bAndroid(?:.+)Mobile\\b/i; // Match 'Android' AND 'Mobile'\r\nconst androidTablet = /Android/i;\r\n```\r\n\r\n当然，不要重复造轮子，推荐一个库: <https://github.com/kaimallea/isMobile>\r\n\r\n``` js\r\nimport isMobile from 'ismobilejs'\r\n\r\nconst mobile = isMobile()\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzQ3MzIxNzM=",
    "number": 212,
    "title": "【Q211】React hooks 中 useCallback 的使用场景是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNTMzMDE1Nw==",
      "body": "能想到的只有两个场景\r\n1. 作为props传递的函数，集合memo一起使用；\r\n2. 作为更新触发的依赖项\r\n主要目的是为了避免高昂的计算和不必要的重复渲染",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "newwangyiyang",
        "url": "https://github.com/newwangyiyang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzUxNTEzNTk=",
    "number": 213,
    "title": "【Q212】在 postgres/mysql 中如何判断当前版本是多少",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NDMzODQ4Mw==",
      "body": "使用 `select version()`\r\n\r\npostgres 示例如下:\r\n\r\n``` sql\r\npostgres@db:school> select version()\r\n+---------------------------------------------------------------------------------------+\r\n| version                                                                               |\r\n|---------------------------------------------------------------------------------------|\r\n| PostgreSQL 12.1 on x86_64-pc-linux-musl, compiled by gcc (Alpine 8.3.0) 8.3.0, 64-bit |\r\n+---------------------------------------------------------------------------------------+\r\nSELECT 1\r\nTime: 0.028s\r\n```\r\n\r\nmysql 示例如下：\r\n\r\n``` sql\r\n> select version()\r\n+-------------+\r\n| version()   |\r\n|-------------|\r\n| 5.6.16-log  |\r\n+-------------+\r\n1 row in set\r\nTime: 0.003s\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzUzNjc3NTg=",
    "number": 214,
    "title": "【Q213】什么是隔离级，都有哪些隔离级",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NDU0ODU5Mg==",
      "body": "隔离级事关并发事务的隔离机制，ANSI SQL 中定义了四种隔离级，分别是\r\n\r\n+ Read Uncommited\r\n+ Read Committed\r\n+ Repetable Read\r\n+ Serializable",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU1MzU2NjM=",
    "number": 215,
    "title": "【Q214】input 中监听值的变化是在监听什么事件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NDY0NTQxNg==",
      "body": "可以**实时**监听值的变化的事件有以下几种\r\n\r\n+ keypress\r\n+ keydown\r\n+ keyup\r\n+ input\r\n\r\n注: `onChange` 无法做到实时监听，因为 onChange 需要失去焦点才能触发",
      "reactions": {
        "totalCount": 2
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjIyOTI=",
    "number": 216,
    "title": "【Q215】什么是跨域，如何解决跨域问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NDk3MjkzOA==",
      "body": "### 跨域\r\n\r\n协议，域名，端口，三者有一不一样，就是跨域\r\n\r\n### 如何解决跨域\r\n\r\n目前有两种最常见的解决方案：\r\n\r\n1. CORS，在服务器端设置几个响应头\r\n1. Reverse Proxy，在 nginx/traefik/haproxy 等反向代理服务器中设置为同一域名\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjQxNDM=",
    "number": 217,
    "title": "【Q216】你对未来的工作有什么期待",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjQ3NTA=",
    "number": 218,
    "title": "【Q217】你对未来的三年规划和五年规划是什么样的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjUwMTM=",
    "number": 219,
    "title": "【Q218】当你入职后发现压力过大怎么办",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzE2OTI=",
    "number": 220,
    "title": "【Q219】工作中你有没有很佩服的人",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzQ0NjQ=",
    "number": 221,
    "title": "【Q220】请简述一下 event loop",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzgwOTU=",
    "number": 222,
    "title": "【Q221】作为技术负责人，你每天的工作是什么样的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzU5Mzg0NTU=",
    "number": 223,
    "title": "【Q222】数据库中如何查看当前的连接数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NDgwNDEwOA==",
      "body": "**PostgresSQL 的最大连接数与当前连接数**\r\n\r\n``` sql\r\n-- 最大连接数\r\nshow max_connections;\r\n\r\n-- 当前连接数\r\nselect count(*) from pg_stat_activity;\r\n```\r\n\r\n**mysql 的最大连接数与当前连接数**\r\n\r\n``` sql\r\n-- 最大连接数\r\nshow variables like 'max_connections';\r\n\r\n-- 当前连接数\r\nshow full processlist;\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYyMzA2MTA=",
    "number": 224,
    "title": "【Q223】数据库查询如何更好地利用数据库缓存进行优化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzYyMzQ1MDM=",
    "number": 225,
    "title": "【Q224】误操作了一个 delete from 语句，如何恢复数据",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzYzNjY1MzE=",
    "number": 226,
    "title": "【Q225】你相比去年，有哪些成长",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzYzNzQyNDI=",
    "number": 227,
    "title": "【Q226】数据库死锁是怎么产生的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NTMyMDc1Mw==",
      "body": "多个事务对资源的交替顺序访问，如\r\n\r\n事务1，访问A表，A表锁住，访问B表，此时B表却被事务2锁住，等待\r\n事务2，访问B表，B表锁住，访问A表，此时A表却被事务1锁住，等待\r\n\r\n由此观之，此死锁出现的条件极为苛刻\r\n\r\n1. 并发，产生多个事务\r\n1. 顺序，对相同资源的不同顺序访问 (干嘛要不同顺序呀)\r\n1. 时机，恰好两个事物都刚刚走完了第一步\r\n\r\n[更多示例](https://www.cnblogs.com/wezheng/p/8366029.html)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYzODE4ODY=",
    "number": 228,
    "title": "【Q227】你如何看待996",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTI3NzMxOQ==",
      "body": "1. 违法\r\n2. 开历史的倒车\r\n3. 容易使员工养成加班文化。最近一新闻提到苏州微软抵制从阿里离职的在职员工搞 996、在工作群里互相攀比加班时间的现象\r\n4. 使员工更不值钱。996 工作制下只有拿到当前工资的 2.275 倍，才在经济账上不吃亏。\r\n5. 对遵循八小时工作制的员工不公平\r\n6. [工作 996，生病 ICU](https://996.icu/#/zh_CN)",
      "reactions": {
        "totalCount": 0
      },
      "author": null
    }
  },
  {
    "id": "MDU6SXNzdWU1NzY3MzE4MjE=",
    "number": 229,
    "title": "【Q228】如何实现一个 flatMap 函数 (头条)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMzg5MTUwMg==",
      "body": "没说不让用flat；所以有个取巧的办法\r\nconst flatMap = arr => arr.flat().map(_ => _);",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "DoubleRayWang",
        "url": "https://github.com/DoubleRayWang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzY4Mzc5Njg=",
    "number": 230,
    "title": "【Q229】在数据库中一个字段如果是字符串类型的，那应该设置哪种数据类型",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NjIwNDExNg==",
      "body": "以下答案仅说明在 postgres 中的情况：\r\n\r\n在 postgres 有三种 `varchar`，`char` 以及 `text`，其中三者没有性能差异，见官方文档\r\n\r\n> Different from other database systems, in PostgreSQL, there is no performance difference among three character types. In most situation, you should use text or varchar, and varchar(n) if you want PostgreSQL to check for the length limit\r\n\r\n所以，选择 `text` 是最好的方案",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzcyNDEyNjQ=",
    "number": 231,
    "title": "【Q230】如何裁剪图片 (情景：选择头像)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzcyNTQwMTQ=",
    "number": 232,
    "title": "【Q231】你周末都喜欢做些什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5Njk1NDQxNA==",
      "body": "打篮球，看电影，看不下书怎么办",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "HoweZhang",
        "url": "https://github.com/HoweZhang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzczMDExOTI=",
    "number": 233,
    "title": "【Q232】当有大量的文本库时，如何做一个字云",
    "body": "如果对去重的每个字都做计数的话，会不会性能过差",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1NzczMTIyNzY=",
    "number": 234,
    "title": "【Q233】一个关于并发更新的事务以及隔离级的问题",
    "body": "当多并发场景下有以下事务执行 (计数器自增)，会出现什么问题\r\n\r\n``` sql\r\nbegin;\r\n\r\n-- select count from counter;\r\n\r\nupdate counter set count = count + 1 where id = 1;\r\n\r\ncommit;\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NjA3MDY3OA==",
      "body": "如果在 pg 下:\r\n\r\n如果隔离级为 RC，则多个事务在更新同一行时，会受到阻塞 (Row Lock)\r\n如果隔离级为 RR，则多个事务在更新同一行时，会报错\r\n\r\n```\r\ncould not serialize access due to concurrent update\r\n```\r\n\r\nmysql 未测试",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1NzczMzAzMTE=",
    "number": 235,
    "title": "【Q234】以下 SQL 语句会有什么问题 (悲观锁)",
    "body": "一个计数器，自增一\r\n\r\n``` sql\r\nbegin;\r\nselect count from user;\r\n\r\n-- 根据以上 SQL 查询出来的 count 来进行自增\r\n-- 如果在此次事务中，已有多次事务对 count 进行了多次更改怎么办？\r\nupdate user set count = $count + 1 where id = 1;\r\ncommit;\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NjA4NjI3MA==",
      "body": "在并发情况下会出现问题，先查看本次事务的流程\r\n\r\n1. 查询当前计数 -> 此时为 10\r\n1. 对当前计数自增 -> 此时为 11？**在自增时，有可能被多并发的其它事务已经自增到 100 了，此时若设置为 11，肯定有问题**\r\n\r\n**如何解决？**\r\n\r\n要在第一步时加锁，同一时间只放行一个事务，可以设置分布式锁和悲观锁\r\n\r\n+ **分布式锁** (redis)：`SET LOCK_KEY RANDOM_VALUE EX 100 NX`\r\n+ **悲观锁**：`select count from user for update`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzg1NjUwNTU=",
    "number": 236,
    "title": "【Q235】useEffect 中如何使用 async/await",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NzA3ODA5NQ==",
      "body": "``` ts\r\nfunction useEffect(effect: EffectCallback, deps?: DependencyList): void;\r\ntype EffectCallback = () => (void | (() => void | undefined));\r\n```\r\n\r\n根据文档及 ts 的提示来看，`useEffect` 的回调参数返回的是一个清除副作用的 `clean-up` 函数。因此无法返回 `Promise`，更无法使用 `async/await`\r\n\r\n``` js\r\nuseEffect(() => {\r\n  const subscription = props.source.subscribe();\r\n  return () => {\r\n    // Clean up the subscription\r\n    subscription.unsubscribe();\r\n  };\r\n});\r\n```\r\n\r\n**此时可以选择再包装一层 async 函数，置于 useEffect 的回调函数中，变相使用 async/await**\r\n\r\n``` jsx\r\nasync function fetchMyAPI() {\r\n  let response = await fetch('api/data')\r\n  response = await res.json()\r\n  dataSet(response)\r\n}\r\n\r\nuseEffect(() => {\r\n  fetchMyAPI();\r\n}, []);\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzg3MDc0MTI=",
    "number": 237,
    "title": "【Q236】主域名的 SEO 是否比二级域名要更好",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTMxMTY1OA==",
      "body": "看场景的。请补充场景。再说这个和前端工程化有啥关系？",
      "reactions": {
        "totalCount": 0
      },
      "author": null
    }
  },
  {
    "id": "MDU6SXNzdWU1NzkxOTExOTg=",
    "number": 238,
    "title": "【Q237】以下代码，koa 会返回什么数据",
    "body": "根据有无 `await next()` 判断以下代码输出结果\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, 1'\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, 1'\r\n  await next()\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  await next()\r\n  ctx.body = 'hello, 1'\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5NzU4MDQyOA==",
      "body": "根据 koa 的洋葱模型，返回结果是\r\n\r\n```\r\nhello, 1\r\n\r\nhello, 2\r\n\r\nhello, 1\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzk5NDY4NTQ=",
    "number": 239,
    "title": "【Q238】什么是服务雪崩，如何避免",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODA5NjAxMzY=",
    "number": 240,
    "title": "【Q239】Node 如何进行进程间通信 ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDU5ODk5MTU4MQ==",
      "body": "对于 spawn/fork 出来的父子进程来说，可以通过 pipe 的方式\r\n\r\n+ `process.on('message')`/`process.send`\r\n+ `stdin.on/stdout.write`\r\n\r\n对于并无相关的进程\r\n\r\n+ `socket`\r\n+ `message queue`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1ODA5NzUxNjc=",
    "number": 241,
    "title": "【Q240】如何实现一个 async/await ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwODU3Mzc2Mg==",
      "body": "```js\r\n/**\r\n * async的执行原理\r\n * 其实就是自动执行generator函数\r\n * 暂时不考虑genertor的编译步骤（更复杂）\r\n */\r\n\r\nconst getData = () =>\r\n  new Promise(resolve => setTimeout(() => resolve(\"data\"), 1000))\r\n\r\n// 这样的一个async函数 应该再1秒后打印data\r\nasync function test() {\r\n  const data = await getData()\r\n  console.log('data: ', data);\r\n  const data2 = await getData()\r\n  console.log('data2: ', data2);\r\n  return 'success'\r\n}\r\n\r\n// async函数会被编译成generator函数 (babel会编译成更本质的形态，这里我们直接用generator)\r\nfunction* testG() {\r\n  // await被编译成了yield\r\n  const data = yield getData()\r\n  console.log('data: ', data);\r\n  const data2 = yield getData()\r\n  console.log('data2: ', data2);\r\n  return 'success'\r\n}\r\n\r\nfunction asyncToGenerator(generatorFunc) {\r\n  return function() {\r\n    const gen = generatorFunc.apply(this, arguments)\r\n\r\n    return new Promise((resolve, reject) => {\r\n      function step(key, arg) {\r\n        let generatorResult\r\n        try {\r\n          generatorResult = gen[key](arg)\r\n        } catch (error) {\r\n          return reject(error)\r\n        }\r\n\r\n        const { value, done } = generatorResult\r\n\r\n        if (done) {\r\n          return resolve(value)\r\n        } else {\r\n          return Promise.resolve(value).then(\r\n            function onResolve(val) {\r\n              step(\"next\", val)\r\n            },\r\n            function onReject(err) {\r\n              step(\"throw\", err)\r\n            },\r\n          )\r\n        }\r\n      }\r\n      step(\"next\")\r\n    })\r\n  }\r\n}\r\n\r\nconst testGAsync = asyncToGenerator(testG)\r\ntestGAsync().then(result => {\r\n  console.log(result)\r\n})\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "sl1673495",
        "url": "https://github.com/sl1673495"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1ODA5ODQxNjI=",
    "number": 242,
    "title": "【Q241】如何使用 async/await 实现 Promise.all 的效果",
    "body": "如获取三个用户的信息，使用 `Promise.all` 的写法\r\n\r\n``` js\r\nconst users = await Promise.all(getUser(1), getUser(2), getUser(3))\r\n```\r\n\r\n那如何不使用 `Promise.all` 实现以上效果",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTI2ODU1Nw==",
      "body": "```js\r\nlet req1 = () => fetch(`https://github.com/shfshanyue/Daily-Question/issues?page=1&q=is%3Aissue+is%3Aopen`);\r\n\r\nlet req2 = () => fetch(`https://github.com/shfshanyue/Daily-Question/issues?page=2&q=is%3Aissue+is%3Aopen`);\r\n\r\nlet req3 = () => fetch(`https://github.com/shfshanyue/Daily-Question/issues?page=3&q=is%3Aissue+is%3Aopen`);\r\n\r\n// promise.all\r\nconst res = await Promise.all([req1(), req2(), req3()]);\r\n\r\nconst res1 = req1()\r\nconst res2 = req2()\r\nconst res3 = req3()\r\n\r\n// await\r\nconst u1 =  await res1\r\nconst u2 =  await res2\r\nconst u3 =  await res3\r\n\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/57755075/89433879-71e1f280-d775-11ea-8772-6c26e58d29c3.png)\r\n",
      "reactions": {
        "totalCount": 1
      },
      "author": null
    }
  },
  {
    "id": "MDU6SXNzdWU1ODEyNDc5ODc=",
    "number": 244,
    "title": "【Q242】有没有用过 continuous local storage，用在了哪里",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODEyNTE3NTg=",
    "number": 245,
    "title": "【Q243】有没有遇到 js 捕捉不到异常堆栈信息的情况",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODE1OTc0MTM=",
    "number": 246,
    "title": "【Q244】Promise 在异步资源的生命周期 (async_hooks) 中是如何被销毁的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODE3NDY4MDQ=",
    "number": 247,
    "title": "【Q245】有没有用过 Promise.allSettled() ，它是干什么的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODE3NDY5ODg=",
    "number": 248,
    "title": "【Q246】谈谈你对微服务的理解，试着画一个脑图",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODQzOTE5NTQ=",
    "number": 249,
    "title": "【Q247】在 node 中如何监听异步资源的生命周期",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODg0MTkwNDY=",
    "number": 250,
    "title": "【Q248】测试中 TDD 与 BDD 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODk3MDc2NjE=",
    "number": 251,
    "title": "【Q249】使用 js 实现一个 lru cache",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1ODk3MzI3NDk=",
    "number": 252,
    "title": "【Q250】刚刚启动了一个服务，如何知道这个服务对应的端口号是多少",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNDU5NjU0Mg==",
      "body": "在linux系统中，我通常通过 `ps -aux |grep 服务名` 查看服务端口",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "wangedison",
        "url": "https://github.com/wangedison"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1ODk5NDAwODU=",
    "number": 253,
    "title": "【Q251】node --max-old-space-size=4096 是什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTAyNTk3MzU=",
    "number": 254,
    "title": "【Q252】https 中如何保证证书是可信任的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTAyNzAzODE=",
    "number": 255,
    "title": "【Q253】cookie 有哪些字段",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwOTQxNTkwOA==",
      "body": "+ path\r\n+ domain\r\n+ key\r\n+ value\r\n+ httpOnly\r\n+ simeSite",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTAyNzQzOTc=",
    "number": 256,
    "title": "【Q254】进程与线程的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTE3NDIzMzU=",
    "number": 257,
    "title": "【Q255】图片防盗链原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwNzEyMzkzNw==",
      "body": "请求头中的 refer 来判断是否屏蔽图片",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI0MjYzNzE=",
    "number": 258,
    "title": "【Q256】如何理解 Node 的异步非阻塞IO",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTQ1Mjk=",
    "number": 259,
    "title": "【Q257】爬虫中如何实现一个调度器",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
        "name": "爬虫"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTQ5ODE=",
    "number": 260,
    "title": "【Q258】如何实现一个分布式的爬虫",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
        "name": "爬虫"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwODk2Nzk5NQ==",
      "body": "可以通过 redis 实现一个分布式的 url 调度器 (Set)，多个分布式爬虫的爬取器从调度器中统一取地址进行爬取",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTU0Nzg=",
    "number": 261,
    "title": "【Q259】爬虫如何实现一个去重器",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
        "name": "爬虫"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTMzMjQ0NjA=",
    "number": 262,
    "title": "【Q260】如何实现单点登录",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwODk2Njg0NA==",
      "body": "一张来 [单点登录原理与简单实现](https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png) 的图\r\n\r\n![](https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTMzNzMyODk=",
    "number": 263,
    "title": "【Q261】当写爬虫时，因爬取过多被禁掉 IP 怎么解决",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
        "name": "爬虫"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwODk2MTMxMA==",
      "body": "可以维护一个 IP 地址池，通过 Proxy 的方式去爬取网页",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTM3MzY5NzA=",
    "number": 264,
    "title": "【Q262】当一个排期五天的任务需要在两天后上线如何解决",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTI0NDM2Mg==",
      "body": "1. 分析任务\r\n这个任务是活动页面开发？还是常规需求？\r\n如果是常规需求，可以考虑延期\r\n如果是活动页面，尤其是节假日、特殊纪念日的活动，可以考虑降低用户体验、砍需求等从而降低工作量，继而保证正常上线。因为运营活动的时效性较高\r\n2. 在排期阶段多估算时间，预计是常规工作时间的 1.5 倍\r\n3. 通过加班等方式弥补工期的缺失",
      "reactions": {
        "totalCount": 0
      },
      "author": null
    }
  },
  {
    "id": "MDU6SXNzdWU1OTM3NTQyOTY=",
    "number": 265,
    "title": "【Q263】你们项目的测试覆盖率是怎么做的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTM3NzI3Mjk=",
    "number": 266,
    "title": "【Q264】当 Node 应用发生 gc 时，如何监控",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTQyOTM1NTE=",
    "number": 267,
    "title": "【Q265】Node 应用中如何查看 gc 的日志",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwOTM3NjExNg==",
      "body": "通过开启参数 `--trace-gc` 与 `--trace-gc-verbose`\r\n\r\n``` bash\r\n$ node --trace-gc index.js\r\n\r\n[10711:0x3507b20]    36425 ms: Mark-sweep 28.6 (48.2) -> 19.3 (46.7) MB, 3.9 / 0.0 ms  (+ 10.4 ms in 8 steps since start of marking, biggest step 6.9 ms, walltime since start of marking 77 ms) (average mu = 0.997, current mu = 0.997) finalize incremental marking via task GC in old space requested\r\n[10711:0x3507b20]    36434 ms: Scavenge 21.0 (46.7) -> 5.7 (46.7) MB, 1.0 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n[10711:0x3507b20]    36494 ms: Scavenge 21.1 (46.7) -> 6.2 (46.7) MB, 2.3 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n[10711:0x3507b20]    36562 ms: Scavenge 21.1 (46.7) -> 6.0 (46.7) MB, 2.8 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n```\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTQ0NTExNDU=",
    "number": 268,
    "title": "【Q266】bind 与 call/apply 的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYwOTQxNTUzNg==",
      "body": "他们都是绑定 this 的，但是\r\n\r\n1. `bind` 返回函数\r\n1. `call/apply` 直接执行函数",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTUxNDcwNDg=",
    "number": 269,
    "title": "【Q267】CSP 是干什么用的了",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyNDQxOTc5Ng==",
      "body": "`CSP` **只允许加载指定的脚本及样式**，**最大限度地防止 `XSS` 攻击**，是解决 XSS 的最优解。CSP 的设置根据加载页面时 http 的响应头 `Content Security Policy` 在服务器端控制。\r\n\r\n1. 外部脚本可以通过指定域名来限制：**`Content-Security-Policy: script-src 'self'`**，`self` 代表只加载当前域名\r\n1. 如果网站必须加载内联脚本 (inline script) ，则可以提供一个 `nonce` 才能执行脚本，攻击者则无法注入脚本进行攻击。**`Content-Security-Policy: script-src 'nonce-xxxxxxxxxxxxxxxxxx'`**\r\n\r\n通过 `devtools -> network` 可见 github 的 CSP 配置如下：\r\n\r\n``` bash\r\nContent-Security-Policy: default-src 'none'; \r\n  base-uri 'self'; \r\n  block-all-mixed-content;\r\n  connect-src 'self' uploads.github.com www.githubstatus.com collector.githubapp.com api.github.com www.google-analytics.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com cdn.optimizely.com logx.optimizely.com/v1/events wss://alive.github.com; \r\n  font-src github.githubassets.com; \r\n  form-action 'self' github.com gist.github.com; \r\n  frame-ancestors 'none'; \r\n  frame-src render.githubusercontent.com; \r\n  img-src 'self' data: github.githubassets.com identicons.github.com collector.githubapp.com github-cloud.s3.amazonaws.com *.githubusercontent.com; \r\n  manifest-src 'self'; \r\n  media-src 'none'; \r\n  script-src github.githubassets.com; \r\n  style-src 'unsafe-inline' github.githubassets.com; \r\n  worker-src github.com/socket-worker.js gist.github.com/socket-worker.js\r\n```\r\n\r\n## 相关链接\r\n\r\n+ [Content Security Policy 入门教程 - 阮一峰](http://www.ruanyifeng.com/blog/2016/09/csp.html)\r\n+ [Content Security Policy - w3](https://www.w3.org/TR/CSP3/#directive-form-action)",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTU4NjcwMjA=",
    "number": 270,
    "title": "【Q268】你如何看待 serverless",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTcyNjcyMzE=",
    "number": 271,
    "title": "【Q269】什么是 XSS 攻击，如何避免",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3ODc4MTc2NA==",
      "body": "CSS (Cross Site Scripting)，跨站脚本攻击。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTczMzI4OTc=",
    "number": 272,
    "title": "【Q270】一张员工表，一个字段代表它的上级，如何查询该员工的所有上级",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU1OTc4ODU4NjY=",
    "number": 273,
    "title": "【Q271】react hooks 的原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNTMzMTg2OA==",
      "body": "闭包 ➕ 链表",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "newwangyiyang",
        "url": "https://github.com/newwangyiyang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU1OTkzMjk2NjE=",
    "number": 274,
    "title": "【Q272】如何查看你们 JS 项目中应采用的 node 版本",
    "body": "当入职新公司，接手一个新的项目时，如何知道这个项目需要的 node 版本是多少",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxMzkxMjU5NQ==",
      "body": "如果项目使用的yarn和typescript，可以查看yarn.lock里的@types/node@* 的version",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "DoubleRayWang",
        "url": "https://github.com/DoubleRayWang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDAyODAyMjA=",
    "number": 275,
    "title": "【Q273】http2 中的首部压缩的实现原理是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxNDAzMTYyOA==",
      "body": "`HPACK` 协议，其中原理是哈夫曼编码及索引表 (看来常用的数据结构及算法要有所了解)，以下内容摘自 [谷歌开发者文档：http2](https://developers.google.com/web/fundamentals/performance/http2/)\r\n\r\n> 每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。 （请参阅测量和控制协议开销。） 为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：\r\n>\r\n> 1. 这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。\r\n> 1. 这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。\r\n\r\n实践出真知，通过 `wireshark` 抓包分析 http2 的报文对理解 http2 收益颇多。\r\n\r\n> 你要有知识，你就得参加变革现实的实践。你要知道梨子的滋味，你就得变革梨子，亲口吃一吃。你要知道原子的组织同性质，你就得实行物理学和化学的实验，变革原子的情况。你要知道革命的理论和方法，你就得参加革命。\r\n\r\n以下是关于抓包信息的截图\r\n\r\n**http2 通过 `Settings` 帧设置 header table size，进行首部压缩**\r\n\r\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f1a9d380a4d47a4aabbbd98af4d3f90~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n**http2 通过首部压缩后，:method 伪标头在索引表中的 Index 为 2**\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b1281937b584bffaa0bbcb9d5621341~tplv-k3u1fbpfcp-zoom-1.image)\r\n\r\n关于常用的标头会存储在静态索引表固定的位置，详见 <https://httpwg.org/specs/rfc7541.html#static.table.definition>\r\n\r\n\r\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cef31dd10e64340b49caf35cbc01759~tplv-k3u1fbpfcp-zoom-1.image)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDEyMDEwNDQ=",
    "number": 276,
    "title": "【Q274】如何获取你们 Node 项目的 cpu profile 快照",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MDEyMzM5NDg=",
    "number": 277,
    "title": "【Q275】解释下 OLTP 与 OLAP",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MDI2NjM4NTQ=",
    "number": 278,
    "title": "【Q276】如何查看 node_modules(某一文件夹) 的体积有多大",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxNjA4MjUxNQ==",
      "body": "`du` (disk usage) 命令可以查看磁盘的使用情况，从它可以看出来文件及目录的大小\r\n\r\n``` bash\r\n# -d 搜索深度，0 指当前目录\r\n# -h 以可读性的方式显示大小\r\n$ du -hd 0 node_modules\r\n132M    node_modules\r\n```\r\n\r\n同理，可以使用以下命令查看 `node_modules` 下每个目录所占的大小\r\n\r\n``` bash\r\n$ du -hd 1 node_modules\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDI2OTQ3MDQ=",
    "number": 279,
    "title": "【Q277】redux 解决什么问题，还有什么其他方案",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNTMzMjM5MQ==",
      "body": "1. mobx\r\n2. useContext ➕ useReducer",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "newwangyiyang",
        "url": "https://github.com/newwangyiyang"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDI2OTQ4NTg=",
    "number": 280,
    "title": "【Q278】为什么不能在表达式里面定义 react hooks",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MDkyNDk4Mg==",
      "body": "https://zh-hans.reactjs.org/docs/hooks-rules.html#explanation",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "Kffhi",
        "url": "https://github.com/Kffhi"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDU2MzU3MTc=",
    "number": 281,
    "title": "【Q279】display: inline 的元素设置 margin 和 padding 会生效吗",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYxODQ3MjE4MQ==",
      "body": "可参考文章 http://maxdesign.com.au/articles/inline/\r\n\r\ninline 元素的 margin 与 padding 左右生效，上下不生效",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYxNDk5ODQ=",
    "number": 282,
    "title": "【Q280】html 的默认 display 属性是多少",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MTc4ODU5Nw==",
      "body": "block      ",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "fariellany",
        "url": "https://github.com/fariellany"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYyNjg3NTA=",
    "number": 283,
    "title": "【Q281】响应式布局需要注意哪一些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NjI2NTUyOQ==",
      "body": "栅格布局？",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "Innocentw",
        "url": "https://github.com/Innocentw"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYyNzU0MDU=",
    "number": 284,
    "title": "【Q282】对一个非定长宽的块状元素如何做垂直水平居中",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTc3MTE2Ng==",
      "body": "flex布局",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "huxiamei",
        "url": "https://github.com/huxiamei"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDg4NjE3NzM=",
    "number": 285,
    "title": "【Q283】http 请求头中的 X-Forwarded-For 代表什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyMTA2MzMzOQ==",
      "body": "`X-Forwarded-For` 被反向代理器生成，如 nginx，traefik 等，一般用作标识客户端真实的 IP 地址，目前已成为事实上的标准。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDk0MzQwODA=",
    "number": 286,
    "title": "【Q284】prefetch 与 preload 的区别是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyMTUyODQ5OQ==",
      "body": "1. `preload` 加载当前路由必需资源，优先级高\r\n1. `prefetch` 优先级低，在浏览器 idle 状态时加载资源。一般用以加载其它路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link  做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源\r\n\r\n> prefetch - Prefetch the page in the background. Defaults to true. Any <Link /> that is in the viewport (initially or through scroll) will be preloaded.\r\n\r\n更多信息可参考以下链接：\r\n\r\n+ [用 preload 预加载页面资源](https://juejin.im/post/5a7fb09bf265da4e8e785c38)\r\n+ [Using Preload and Prefetch in Your HTML to Load Assets](https://alligator.io/html/preload-prefetch/)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MDk3MTU2NjE=",
    "number": 287,
    "title": "【Q285】有没有做过裁剪头像图片的需求，如何实现",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MDk3NDM2NTY=",
    "number": 288,
    "title": "【Q286】在服务端应用中如何获得客户端 IP",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyMTcxNTI4NA==",
      "body": "**如果有 `x-forwarded-for` 的请求头，则取其中的第一个 IP，否则取建立连接 socket 的 remoteAddr。**\r\n\r\n而 `x-forwarded-for` 基本已成为了基于 proxy 的标准HTTP头，格式如下，可见第一个 IP 代表其真实的 IP，可以参考 MDN [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)\r\n\r\n``` js\r\nX-Forwarded-For: 203.0.113.195, 70.41.3.18, 150.172.238.178\r\nX-Forwarded-For: <client>, <proxy1>, <proxy2>\r\n```\r\n\r\n以下是 `koa` 获取 IP 的方法\r\n\r\n``` js\r\n  get ips() {\r\n    const proxy = this.app.proxy;\r\n    const val = this.get(this.app.proxyIpHeader);\r\n    let ips = proxy && val\r\n      ? val.split(/\\s*,\\s*/)\r\n      : [];\r\n    if (this.app.maxIpsCount > 0) {\r\n      ips = ips.slice(-this.app.maxIpsCount);\r\n    }\r\n    return ips;\r\n  },\r\n\r\n  get ip() {\r\n    if (!this[IP]) {\r\n      this[IP] = this.ips[0] || this.socket.remoteAddress || '';\r\n    }\r\n    return this[IP];\r\n  },\r\n```\r\n\r\n参见源码: <https://github.com/koajs/koa/blob/master/lib/request.js#L433>",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MTE5NDk0NDE=",
    "number": 289,
    "title": "【Q287】在 redis 中如何查看版本号",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyMzUyMTQ0OA==",
      "body": "``` bash\r\n$ redis-server -v\r\nRedis server v=5.0.7 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=fbc6fab733127977\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MTI1OTQ4Nzc=",
    "number": 290,
    "title": "【Q288】如何求数组中的 TOP k",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYyNDA1NDE1Nw==",
      "body": "1. 取数组中前 k 个数做小顶堆，堆化\r\n1. 数组中的其它数逐一与堆顶元素比较，若大于堆顶元素，则插入该数\r\n\r\n时间复杂度 O(nlg(k))",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MTQ4MTcxNzQ=",
    "number": 291,
    "title": "【Q289】Node 中循环引用会发生什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MTQ4MTc0Nzg=",
    "number": 292,
    "title": "【Q290】Node 中 require 时发生了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MTU4MjgwMzc=",
    "number": 293,
    "title": "【Q291】简述 node/v8 中的垃圾回收机制",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MzkzMjE3OA==",
      "body": "`v8` 中的垃圾回收机制分为三种\r\n\r\n1. `Scavenge`，工作在新生代，把 `from space` 中的存活对象移至 `to space`\r\n1. `Mark-Sweep`，标记清除。新生代的某些对象由于过度活跃会被移至老生代，此时对老生代中活对象进行标记，并清理死对象\r\n1. `Mark-Compact`，标记整理。\r\n\r\n## 相关链接\r\n\r\n1. [主流的垃圾回收机制都有哪些?](https://www.zhihu.com/question/32373436)\r\n1. [各种编程语言的实现都采用了哪些垃圾回收算法](https://www.zhihu.com/question/20018826)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjMwNjE1NDk=",
    "number": 294,
    "title": "【Q292】peerDependency 是为了解决什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzMjc3NDYyOA==",
      "body": "<https://indepth.dev/npm-peer-dependencies/>",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjMzMTk4NDM=",
    "number": 295,
    "title": "【Q293】semver 指什么，试图解释一下",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjM4NDQzODI=",
    "number": 296,
    "title": "【Q294】optionalDependencies 的使用场景是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzMzIxOTM3Mg==",
      "body": "当一个包是可依赖可不依赖时，可采用 `optionalDependencies`，但需要在代码中做好异常处理。\r\n\r\n如 [chokidar](https://github.com/paulmillr/chokidar) 对 `fsevents` 的引入\r\n\r\n``` json\r\n{\r\n  \"optionalDependencies\": {\r\n    \"fsevents\": \"~2.1.2\"\r\n  }\r\n}\r\n```\r\n\r\n``` js\r\nlet fsevents;\r\ntry {\r\n  fsevents = require('fsevents');\r\n} catch (error) {\r\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjQ2OTc5NDY=",
    "number": 297,
    "title": "【Q295】fetch 中 crendentials 指什么意思，可以取什么值",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzMzg4ODYyNQ==",
      "body": "`credentials` 指在使用 `fetch` 发送请求时是否应当发送 `cookie`\r\n\r\n+ `omit`: 从不发送 `cookie`.\r\n+ `same-origin`: 同源时发送 `cookie`  (浏览器默认值)\r\n+ `include`: 同源与跨域时都发送 `cookie`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjQ5NDM2NDc=",
    "number": 298,
    "title": "【Q296】package-lock.json 与 yarn.lock 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjUzODM5MzY=",
    "number": 299,
    "title": "【Q297】服务器的平均负载如何计算",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNDQzNTExOA==",
      "body": "`load average` 指单位时间内运行态进程及不可中断进程的平均进程数，运行态进程指正在使用或者\r\n 等待使用 CPU 的进程，不可中断进程指正等待一些 IO 操作的进程。可使用 `uptime` 查看此指标。\r\n\r\n ```bash\r\n $ uptime\r\n  16:48:09 up 2 days, 23:43,  2 users,  load average: 0.01, 0.21, 0.20\r\n ```\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjU0NzI2ODk=",
    "number": 300,
    "title": "【Q298】如何创建一个进程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNTA1NTY0NQ==",
      "body": "+ `exec`\r\n+ `fork`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjU1NjAzNTQ=",
    "number": 301,
    "title": "【Q299】serverless 中如何得知目前扩容了多少个实例",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMDkxMTQ2MDM3",
        "name": "serverless"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjU1NjEwMzM=",
    "number": 302,
    "title": "【Q300】node 中 exec，fork 与 spawn 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjYyMjAyMjg=",
    "number": 303,
    "title": "【Q301】base64 由哪64个字符构成",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNTEwNjk2NQ==",
      "body": "`A-Z`，`a-z`，`0-9`，`+`，`/`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyNTg4NDQ=",
    "number": 304,
    "title": "【Q302】多服务器的系统时间不一致如何解决",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNTIzODU5OA==",
      "body": "ntp服务",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "sk-xie",
        "url": "https://github.com/sk-xie"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyNzY4MDA=",
    "number": 305,
    "title": "【Q303】在 k8s 中如何自定义 CRD 资源",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjYyNzc5OTc=",
    "number": 306,
    "title": "【Q304】service mesh 是什么，能够解决什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjgxMzczMzQ=",
    "number": 307,
    "title": "【Q305】如何删除项目中没有使用到的 package",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNjYwMjUzMQ==",
      "body": "可以采用 [depcheck](https://github.com/depcheck/depcheck) 来完成这件事\r\n\r\n``` js\r\n$ npm install depcheck -g\r\n\r\n$ depcheck\r\nUnused dependencies\r\n* underscore\r\nUnused devDependencies\r\n* jasmine\r\nMissing dependencies\r\n* lodash\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkwOTQ1OTU=",
    "number": 308,
    "title": "【Q306】如何实现左右固定，中间自适应布局",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MDYxMTkzOA==",
      "body": "可以参考 [【Q017】css 如何实现左侧固定300px，右侧自适应的布局](https://github.com/shfshanyue/Daily-Question/issues/18)\r\n\r\n\r\n``` pug\r\n.container\r\n  .left\r\n  .main\r\n  .right\r\n```\r\n\r\n``` css\r\n.container {\r\n  display: flex;\r\n}\r\n\r\n.left {\r\n  flex-basis: 300px;\r\n  flex-shrink: 0;\r\n}\r\n\r\n.right {\r\n  flex-basis: 300px;\r\n  flex-shrink: 0;\r\n}\r\n\r\n.main {\r\n  flex-grow: 1;\r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkwOTU0MjE=",
    "number": 309,
    "title": "【Q307】如何实现表格单双行条纹样式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDYzNzQ1MjAyOA==",
      "body": "通过 `css3` 中伪类 `:nth-child` 来实现。其中 `:nth-child(an+b)` 匹配下标 `{ an + b; n = 0, 1, 2, ...} ` 且结果为整数的子元素\r\n\r\n+ `nth-child(2n)`/`nth-child(even)`: 双行样式\r\n+ `nth-child(2n+1)`/`nth-child(odd)`: 单行样式\r\n\r\n其中 `tr` 在表格中代表行，实现表格中单双行样式就很简单了：\r\n\r\n``` css\r\ntr:nth-child(2n) {\r\n  background-color: red;\r\n}\r\n\r\n\r\ntr:nth-child(2n+1) {\r\n  background-color: blue;\r\n}\r\n```\r\n\r\n同理：\r\n\r\n1. 如何匹配最前三个子元素: `:nth-child(-n+3)`\r\n1. 如何匹配最后三个子元素: `:nth-last-child(-n+3)`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkxMDIxMjI=",
    "number": 310,
    "title": "【Q308】node 中 dns.resolve 及 dns.lookup 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MjkxMTMxNDk=",
    "number": 311,
    "title": "【Q309】简述下 css specificity",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MDYxNjUyMA==",
      "body": "`css specificity` 即 css 中关于选择器的权重，以下三种类型的选择器依次下降\r\n\r\n1. `id` 选择器，如 `#app`\r\n1. `class`、`attribute` 与 `pseudo-classes` 选择器，如 `.header`、`[type=\"radio\"]` 与 `:hover`\r\n1. `type` 标签选择器和伪元素选择器，如 `h1`、`p` 和 `::before`\r\n\r\n其中通配符选择器 `*`，组合选择器 `+ ~ >`，否定伪类选择器 `:not()` 对优先级无影响\r\n\r\n另有内联样式 `<div class=\"foo\" style=\"color: red;\"></div>` 及 `!important`(最高) 具有更高的权重\r\n\r\n> [`:not` 的优先级影响 - codepen](https://codepen.io/shanyue/pen/dyGQqBe) 可以看出 `:not` 对选择器的优先级无任何影响",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkyNzA3MDM=",
    "number": 312,
    "title": "【Q310】Node 中 require json 文件数据时，如何当文件更新时，重新 require",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Mjk3NzA2MTI=",
    "number": 313,
    "title": "【Q311】当 cookie 没有设置 maxage 时，cookie 会存在多久",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MjI2OTQ2OQ==",
      "body": "不设置max-age和expires，此cookie就是会话级别的，浏览器关闭就没了\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "lznbuild",
        "url": "https://github.com/lznbuild"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Mjk4NTYxMjY=",
    "number": 314,
    "title": "【Q312】如何实现 Promise.race",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzA0NjU4MTY=",
    "number": 315,
    "title": "【Q313】在浏览器中如何监听剪切板中内容",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MDk4NTczMg==",
      "body": "通过 `Clipboard API` 可以获取剪切板中内容，但需要获取到 `clipboard-read` 的权限，以下是关于读取剪贴板内容的代码：\r\n\r\n``` js\r\n// 是否能够有读取剪贴板的权限\r\n// result.state == \"granted\" || result.state == \"prompt\"\r\nconst result = await navigator.permissions.query({ name: \"clipboard-read\" })\r\n\r\n// 获取剪贴板内容\r\nconst text = await navigator.clipboard.readText()\r\n```\r\n\r\n > 注: 该方法在 `devtools` 中不生效\r\n\r\n相关问题: [【Q019】如何实现选中复制的功能](https://github.com/shfshanyue/Daily-Question/issues/20)\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA2ODYyNDE=",
    "number": 316,
    "title": "【Q314】source 与 sh 执行脚本时有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMTA5NjQyNTA2",
        "name": "shell"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzA3NDY1OTY=",
    "number": 317,
    "title": "【Q315】'+' 与 '~' 选择器有什么不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MTMzNDkzOQ==",
      "body": "+ `+` 选择器匹配紧邻的兄弟元素\r\n+ `~` 选择器匹配随后的所有兄弟元素",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NDg1MTU=",
    "number": 318,
    "title": "【Q316】node 中如何查看函数异步调用栈",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTAzMTY=",
    "number": 319,
    "title": "【Q317】有哪些 css 属性不能展示动画效果",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTI3ODk=",
    "number": 320,
    "title": "【Q318】如何设计 prometheus 中的 metric",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTMxNzg=",
    "number": 321,
    "title": "【Q319】css 动画与 js 动画哪个性能更好",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4NTQzNjIzMQ==",
      "body": "CSS3的动画：\r\n　　1.在性能上会稍微好一些，浏览器会对CSS3的动画做一些优化（比如专门新建一个图层用来跑动画）\r\n　　2.代码相对简单\r\n　　3.在动画控制上不够灵活\r\n　　4.兼容性不好\r\n　　5.部分动画功能无法实现（如滚动动画，视差滚动等）\r\nJavaScript的动画：\r\n      正好弥补了css缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容IE6，并且功能强大。\r\n总结：\r\n       对于一些复杂控制的动画，使用javascript会比较好。而在实现一些小的交互动效的时候，可以多考虑CSS",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "1178518969",
        "url": "https://github.com/1178518969"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTQzNzI=",
    "number": 322,
    "title": "【Q320】如何衡量 serverless 的冷启动时间",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMDkxMTQ2MDM3",
        "name": "serverless"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTk1Njk=",
    "number": 323,
    "title": "【Q321】 css 中属性选择器及类选择器的权重哪个高",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4NTQ0Nzc2Mw==",
      "body": ".box  权重是10  ，div[class=box]权重可以看成11\r\ndiv .box 和 div[class=box]权重是一样的",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "1178518969",
        "url": "https://github.com/1178518969"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA4NjYwNDg=",
    "number": 324,
    "title": "【Q322】有没有接触过 fs-extra，它是解决什么问题的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzE1MDA4MzQ=",
    "number": 325,
    "title": "【Q323】在 k8s 中如何通过日志查看某条请求进入的 pod",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzQyNTk1NjY=",
    "number": 327,
    "title": "【Q324】为什么会发生样式抖动",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzQzMjgzOTQ=",
    "number": 328,
    "title": "【Q325】关于 cors 的响应头有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MTYxNjcwNQ==",
      "body": "- `Access-Control-Allow-Origin`\r\n- `Access-Control-Allow-Methods`\r\n- `Access-Control-Allow-Headers`\r\n- `Access-Control-Allow-Credentials`\r\n- `Access-Control-Expose-Headers`\r\n- `Access-Control-Max-Age`\r\n\r\n关于如何写一个 `cors` 的中间件可以参考 [koajs/cors](https://github.com/koajs/cors)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzUwODMwMTU=",
    "number": 329,
    "title": "【Q326】如何发现 redis 中的 bigkey",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzUzMzk3NTg=",
    "number": 330,
    "title": "【Q327】如何避免 CDN 为 PC 端缓存移动端页面",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NzE1NTk1OA==",
      "body": "如果 PC 端和移动端是一套代码则不会出现这个问题。**这个问题出现在 PC 端和移动端是两套代码，却共用一个域名。**\r\n\r\n使用 `nginx` 配置如下，根据 UA 判断是否移动端，而走不同的逻辑 (判断UA是否移动端容易出问题)\r\n\r\n``` conf\r\nlocation / {\r\n    // 默认 PC 端\r\n    root /usr/local/website/web;\r\n    \r\n    # 判断 UA，访问移动端\r\n    if ( $http_user_agent ~* \"(Android|webOS|iPhone|iPad|BlackBerry)\" ){ \r\n        root /usr/local/website/mobile;\r\n    }\r\n \r\n    index index.html index.htm;\r\n}\r\n```\r\n\r\n解决方案通常使用 `Vary` 响应头，来控制 CDN 对不同请求头的缓存。\r\n\r\n**此处可以使用 `Vary: User-Agent` ，代表如果 User-Agent 不一样，则重新发起请求，而非从缓存中读取页面**\r\n\r\n``` txt\r\nVary: User-Agent\r\n```\r\n\r\n当然，`User-Agent` 实在过多，此时缓存失效就会过多。\r\n\r\n## 简答\r\n\r\n使用 `Vary: User-Agent`，根据 UA 进行缓存。\r\n\r\n``` txt\r\nVary: User-Agent\r\n```\r\n\r\n但最好不要出现这种情况，PC 端和移动端如果是两套代码，建议用两个域名，理由如下\r\n\r\n1. `nginx` 判断是否移动端容易出错\r\n1. 对缓存不友好\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzUzNDI3Mzk=",
    "number": 331,
    "title": "【Q328】简述 bloomfilter，及它的使用场景是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
        "name": "data-structure"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzU0ODUwMTQ=",
    "number": 332,
    "title": "【Q329】什么是一致性哈希，可以解决什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
        "name": "data-structure"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTU1NDQ=",
    "number": 333,
    "title": "【Q330】mysql 如何开启及查看慢查询日志",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTcwMDI=",
    "number": 334,
    "title": "【Q331】当分页10000页时数据库查询 offset 过大如何解决性能问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTg5MTA=",
    "number": 335,
    "title": "【Q332】当数据库进行版本升级时，如何进行数据迁移",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxNzY0NTM=",
    "number": 336,
    "title": "【Q333】mysql 是如何实现 MVCC 的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxNzk4NTc=",
    "number": 337,
    "title": "【Q334】position: sticky 如何工作，适用于哪些场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MTk0OTUzMA==",
      "body": "`position: sticky` 可理解为 `relative` 与 `fixed` 的结合体",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxODE2NDM=",
    "number": 338,
    "title": "【Q335】什么是层叠上下文 (stacking contect)，谈谈对它的理解",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxODgzNDQ=",
    "number": 339,
    "title": "【Q336】你用 css 实现过什么不错的效果",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxODkzNzY=",
    "number": 340,
    "title": "【Q337】你做前端有多少时间花在写 css 上",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NjE5NzQ4NQ==",
      "body": "非常多",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "Innocentw",
        "url": "https://github.com/Innocentw"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTAwNTA=",
    "number": 341,
    "title": "【Q338】js 中在 new 的时候发生了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczMzQ0Mzk5NQ==",
      "body": "1. 创建了一个新对象\r\n2. 链接到原型\r\n3. 绑定this指向\r\n4.返回这个对象\r\n\r\n```js\r\nfunction _new() {\r\n let obj = {}\r\n let Con = [].shift.call(arguments)\r\n obj.__proto__ = Con.prototype\r\n let result = Con.apply(obj, arguments)\r\n return typeof obj === 'object' ? obj : {}\r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "XJHxjh0118",
        "url": "https://github.com/XJHxjh0118"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTEwMjE=",
    "number": 342,
    "title": "【Q339】伪类与伪元素有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MDYxNzY4OQ==",
      "body": "1. 伪类使用单冒号，而伪元素使用双冒号。如 `:hover` 是伪类，`::before` 是伪元素\r\n1. 伪元素会在文档流生成一个新的元素，并且可以使用 `content` 属性设置内容\r\n\r\n参考 <https://www.w3.org/TR/CSS2/selector.html#pseudo-elements>",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTM5MjU=",
    "number": 343,
    "title": "【Q440】试着讲述数据库的几个范式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTUyNTQ=",
    "number": 344,
    "title": "【Q341】为什么在 mysql 不能够使用 = null",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTkwMDQ=",
    "number": 345,
    "title": "【Q342】`A, B` 复合索引时，`A=? and B=?` 与 `B=? and A=?` 效果是否一致",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzY3NDk0Nzc=",
    "number": 346,
    "title": "【Q343】如何查找地图中某个点两公里内的餐厅",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
        "name": "data-structure"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzY3Nzg5NjA=",
    "number": 347,
    "title": "【Q344】如何列出所有已合并到 master 的分支并删除",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
        "name": "git"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MjQ2MTk3MQ==",
      "body": "``` bash\r\n# 列出所有已合并到 master 的分支\r\n$ git branch --merged master\r\n\r\n# 删除所有已合并到 master 的分支\r\n$ git branch --merged master | grep -v '^\\*' | xargs git branch -d\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzY5NzcxNjU=",
    "number": 348,
    "title": "【Q345】postgres 中 Index Scan 与 Index Only Scan 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MjY3MjcyOQ==",
      "body": "假设在 `user` 表简历索引 (name, age)\r\n\r\nIndex Scan 指查询中除利用索引外还有额外的查询条件，如 (name, age) 是索引，但是 sex 不是\r\n\r\n``` sql\r\nselect * from user where name = '张三' and age = 10 and sex = 'MALE'\r\n```\r\n\r\nIndex Only Scan 指查询中可以全部利用索引，如 (name, age) 都是索引\r\n\r\n``` sql\r\nselect * from user where name = '张三' and age = 10\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzc1NTM2Njk=",
    "number": 349,
    "title": "【Q346】Sentry 中 `withScope`，`configureScope` 与 直接 setTags 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Mzc2NzEwNTE=",
    "number": 350,
    "title": "【Q347】在 node 中如何开启 https",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MzIxMjcxMw==",
      "body": "在 `express` 中开启 https，如下代码所示\r\n\r\n``` js\r\nimport path from 'path'\r\nimport fs from 'fs'\r\nimport express from 'express'\r\nimport http from 'http'\r\nimport https from 'https'\r\n\r\nconst app = express();\r\n\r\nconst cred = {\r\n  key: fs.readFileSync(path.resolve(__dirname, '../key.pem')),\r\n  cert: fs.readFileSync(path.resolve(__dirname, '../cert.pem'))\r\n}\r\nconst httpServer = http.createServer(app)\r\nconst httpsServer = https.createServer(cred, app)\r\n\r\nhttpServer.listen(8000);\r\nhttpsServer.listen(8888);\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgwODI1NDU=",
    "number": 351,
    "title": "【Q348】node 中 module.exports 与 exports 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MTA5NzQzMQ==",
      "body": "**一句话：`exports` 是 `module.exports` 的引用，如果 `exports` 没有重赋值，则二者没有任何区别**\r\n\r\n类似如下所示\r\n\r\n``` js\r\nconst exports = module.exports\r\n```\r\n\r\n那如下结果会如何导出？\r\n\r\n``` js\r\nmodule.exports = 100\r\nexports = 3\r\n```\r\n\r\n很显然会导出 100，毕竟 `exports` 进行了重赋值。\r\n\r\n**那在 node 源码中如何实现的呢？** 从源码里可以看出 **exports** 的实质\r\n\r\n![module wrapper](https://shanyue.tech/assets/img/module-wrapper.70557e4e.png)\r\n\r\n详见源码: <https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L1252>，可以看出符合猜想\r\n\r\n众所周知，node 中所有的模块代码都被包裹在这个函数中\r\n\r\n``` js\r\n(function(exports, require, module, __filename, __dirname) {\r\n  exports.a = 3\r\n});\r\n```\r\n\r\n而以下源码指出，`exports` 是如何得来\r\n\r\n``` js\r\nconst dirname = path.dirname(filename);\r\nconst require = makeRequireFunction(this, redirects);\r\nlet result;\r\n// 从这里可以看出来 exports 的实质\r\nconst exports = this.exports;\r\nconst thisValue = exports;\r\nconst module = this;\r\nif (requireDepth === 0) statCache = new Map();\r\nif (inspectorWrapper) {\r\n  result = inspectorWrapper(compiledWrapper, thisValue, exports,\r\n                            require, module, filename, dirname);\r\n} else {\r\n\r\n  // 这里是模块包装函数\r\n  result = compiledWrapper.call(thisValue, exports, require, module,\r\n                                filename, dirname);\r\n}\r\n```\r\n\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgxMzY2ODg=",
    "number": 352,
    "title": "【Q349】如何把 json 数据转化为 demo.json 并下载文件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0MzYwMzAyNA==",
      "body": "json 视为字符串，可以利用 `DataURL` 进行下载\r\n\r\n`Text -> DataURL`\r\n\r\n除了使用 DataURL，还可以转化为 Object URL 进行下载\r\n\r\n`Text -> Blob -> Object URL`\r\n\r\n可以把以下代码直接粘贴到控制台下载文件\r\n\r\n``` js\r\nfunction download (url, name) {\r\n  const a = document.createElement('a')\r\n  a.download = name\r\n  a.rel = 'noopener'\r\n  a.href = url\r\n  // 触发模拟点击\r\n  a.dispatchEvent(new MouseEvent('click'))\r\n  // 或者 a.click()\r\n}\r\n\r\nconst json = {\r\n  a: 3,\r\n  b: 4,\r\n  c: 5\r\n}\r\nconst str = JSON.stringify(json, null, 2)\r\n\r\n// 方案一：Text -> DataURL\r\nconst dataUrl = `data:,${str}`\r\ndownload(dataUrl, 'demo.json')\r\n\r\n// 方案二：Text -> Blob -> ObjectURL\r\nconst url = URL.createObjectURL(new Blob(str.split('')))\r\ndownload(url, 'demo1.json')\r\n```\r\n\r\n## 总结\r\n\r\n1. 模拟下载，可以通过新建一个 `<a href=\"url\" download><a>` 标签并设置 `url` 及 `download` 属性来下载\r\n2. 可以通过把 `json` 转化为 `dataurl` 来构造 URL\r\n3. 可以通过把 `json` 转换为 `Blob` 再转化为 `ObjectURL` 来构造 URL",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgxODI2ODI=",
    "number": 353,
    "title": "【Q350】如何实现一个 timeout 的中间件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
        "name": "micro-service"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2MzgzMTkyNDk=",
    "number": 354,
    "title": "【Q351】如何得知目前 node 版本的 v8 版本号",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0Mzc0MzQ5MQ==",
      "body": "在 `process.versions` 中可以查看 node 及相关依赖的版本号\r\n\r\n``` js\r\n> process.versions\r\n{\r\n  node: '12.16.3',\r\n  v8: '7.8.279.23-node.35',\r\n  uv: '1.34.2',\r\n  zlib: '1.2.11',\r\n  brotli: '1.0.7',\r\n  ares: '1.16.0',\r\n  modules: '72',\r\n  nghttp2: '1.40.0',\r\n  napi: '5',\r\n  llhttp: '2.0.4',\r\n  http_parser: '2.9.3',\r\n  openssl: '1.1.1g',\r\n  cldr: '36.0',\r\n  icu: '65.1',\r\n  tz: '2019c',\r\n  unicode: '12.1'\r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzg0OTQ3MjU=",
    "number": 355,
    "title": "【Q352】k8s 中如何删除所有 Evicted 状态的 pod",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NDkwMjk2Mw==",
      "body": "```\r\nkubectl delete po --field-selector status.phase=Evicted\r\n```\r\n\r\n更加精确。",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "wi1dcard",
        "url": "https://github.com/wi1dcard"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzg2NjQ5OTc=",
    "number": 356,
    "title": "【Q353】k8s 中 Deployment 与 StatefulSet 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
        "name": "k8s"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NDExMTc0NDg=",
    "number": 357,
    "title": "【Q354】在 node 中如何判断一个对象是 stream",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2NzY4NTczNg==",
      "body": "`stream` 可以通过缓冲区来高效利用内存，从而提高性能。常用场景如读写大文件、http-server 中的大静态文件渲染。\r\n\r\n**每一个 stream 都有 `pipe` 函数，可以用来判断一个对象是否 `stream`**。\r\n\r\n代码如下，摘自 [is-stream](https://github.com/sindresorhus/is-stream/blob/master/index.js): 一个周下载量两千万的 npm package。\r\n\r\n``` js\r\nconst isStream = stream =>\r\n\tstream !== null &&\r\n\ttypeof stream === 'object' &&\r\n\ttypeof stream.pipe === 'function';\r\n\r\nisStream.writable = stream =>\r\n\tisStream(stream) &&\r\n\tstream.writable !== false &&\r\n\ttypeof stream._write === 'function' &&\r\n\ttypeof stream._writableState === 'object';\r\n\r\nisStream.readable = stream =>\r\n\tisStream(stream) &&\r\n\tstream.readable !== false &&\r\n\ttypeof stream._read === 'function' &&\r\n\ttypeof stream._readableState === 'object';\r\n\r\nisStream.duplex = stream =>\r\n\tisStream.writable(stream) &&\r\n\tisStream.readable(stream);\r\n\r\nisStream.transform = stream =>\r\n\tisStream.duplex(stream) &&\r\n\ttypeof stream._transform === 'function' &&\r\n\ttypeof stream._transformState === 'object';\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NDEyMTEzNTY=",
    "number": 358,
    "title": "【Q355】什么是 Iterable 对象，与 Array 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY0Njk5MTA4Mw==",
      "body": "实现了 `[Symbol.iterator]` 属性的对象即是 `Iterable` 对象，然后可以使用操作符 `for...of` 进行迭代\r\n\r\n``` js\r\n```\r\n\r\n详细参考 <https://javascript.info/iterable>",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NDI0NzczMTE=",
    "number": 360,
    "title": "【Q356】在 node 端如何向服务器上传文件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NDU2MTg2MDg=",
    "number": 361,
    "title": "【Q357】js 如何全部替代一个子串为另一个子串",
    "body": "假设有一个字符串 `hello. hello. hello. ` 需要替换为 `AAA`，即把 `hello. ` 替换为 `A`",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1MTU2NDM3Ng==",
      "body": "如果需要全量替换字符串，可以使用 `String.prototype.replace(re, replacer)`，其中正则表达式需要开启 `global` flag\r\n\r\n``` js\r\nconst s = 'foo foo foo'\r\ns.replce(/foo/g, 'bar')\r\n```\r\n\r\n那如题中，**是否可以使用正则表达式来替代子串**\r\n\r\n答：**不可以，因为使用子串构建正则时，有可能有特殊字符，就有可能出现问题**，如下\r\n\r\n``` js\r\n// 期待结果: 'AhelloX hello3 '\r\n> 'hello. helloX hello3 '.replace(new RegExp('hello. ', 'g'), 'A')\r\n< \"AAA\"\r\n```\r\n\r\n而在 `javascript` 中替换子串只能使用一种巧妙的办法：`str.split('foo').join('bar')`\r\n\r\n``` js\r\n> 'hello. hello. hello. '.split('hello. ').join('A')\r\n< \"AAA\"\r\n```\r\n\r\n真是一个巧(笨)妙(拙)的办法啊！！！！！**大概 TC39 也意识到了一个问题，于是出了一个新的 API**，在 `ESNext` 中\r\n\r\n``` js\r\nString.prototype.replaceAll()\r\n\r\n'aabbcc'.replaceAll('b', '.'); \r\n// 'aa..cc'\r\n```\r\n\r\n详细文档在 [String.prototype.replaceAll](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll)\r\n\r\n## 总结(及直接答案)\r\n\r\n两种办法\r\n\r\n+ `str.split('foo').join('bar')`\r\n+ `str.replaceAll('foo', 'bar')`，在 `ESNext` 中，目前支持性不好",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTMxOTc1Njk=",
    "number": 363,
    "title": "【Q358】什么情况下会发送 OPTIONS 请求",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NjUyMzIyNQ==",
      "body": "[搬运地址](https://blog.csdn.net/kahhy/article/details/81563063)\r\n1:请求的方法不是GET/HEAD/POST\r\n2:POST请求的Content-Type 异常\r\n3:请求设置了自定义的header字段\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "hedongxiaoshimei",
        "url": "https://github.com/hedongxiaoshimei"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTMzMzY1MjQ=",
    "number": 364,
    "title": "【Q359】CORS 如果需要指定多个域名怎么办",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NTg2Mjg2NA==",
      "body": "`CORS` 通过控制 `Access-Control-Allow-Origin` 控制哪些域名可以共享资源，取值如下\r\n\r\n``` bash\r\nAccess-Control-Allow-Origin: <origin> | *\r\n```\r\n\r\n其中 `*` 代表所有域名，`origin` 代表指定特定域名，那如何设置多个域名了？\r\n\r\n此时需要通过代码实现，**根据请求头中的 `Origin` 来设置响应头 `Access-Control-Allow-Origin`**，那 Origin 又是什么东西？\r\n\r\n## 请求头: Origin\r\n\r\n并不是所有请求都会自动带上 `Origin`，在浏览器中带 `Origin` 的逻辑如下\r\n\r\n1. 如果存在跨域，则带上 `Origin`，值为当前域名\r\n1. 如果不存在跨域，则不带 `Origin`\r\n\r\n逻辑理清楚后，关于服务器中对于 `Access-Control-Allow-Origin` 设置多域名的逻辑也很清晰了\r\n\r\n1. 如果请求头不带有 `Origin`，证明未跨域，则不作任何处理\r\n1. 如果请求头带有 `Origin`，证明跨域，根据 `Origin` 设置相应的 `Access-Control-Allow-Origin: <Origin>`\r\n\r\n使用伪代码实现如下:\r\n\r\n``` js\r\n// 获取 Origin 请求头\r\nconst requestOrigin = ctx.get('Origin');\r\n\r\n// 如果没有，则跳过\r\nif (!requestOrigin) {\r\n  return await next();\r\n}\r\n\r\n// 设置响应头\r\nctx.set('Access-Control-Allow-Origin', requestOrigin)\r\n```\r\n\r\n## Vary: Origin\r\n\r\n此时可以给多个域名控制 CORS，但此时假设有两个域名访问 `static.shanyue.tech` 的跨域资源\r\n\r\n1. `foo.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`\r\n1. `bar.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: bar.shanyue.tech`\r\n\r\n看起来一切正常，但如果中间有缓存怎么办？\r\n\r\n1. `foo.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`，被 CDN 缓存\r\n1. **`bar.shanyue.tech`，因由缓存，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`，跨域出现问题**\r\n\r\n此时，`Vary: Origin` 就上场了，代表为不同的 `Origin` 缓存不同的资源\r\n\r\n## 总结 (简要答案)\r\n\r\nCORS 如何指定多个域名？\r\n\r\n**根据请求头中的 `Origin` 来设置响应头 `Access-Control-Allow-Origin`**，思路如下\r\n\r\n1. 总是设置 `Vary: Origin`，避免 CDN 缓存破坏 CORS 配置\r\n1. 如果请求头不带有 `Origin`，证明未跨域，则不作任何处理\r\n1. 如果请求头带有 `Origin`，证明浏览器访问跨域，根据 `Origin` 设置相应的 `Access-Control-Allow-Origin: <Origin>` \r\n\r\n使用伪代码实现如下\r\n\r\n``` js\r\n// 获取 Origin 请求头\r\nconst requestOrigin = ctx.get('Origin');\r\n\r\nctx.set('Vary', 'Origin')\r\n\r\n// 如果没有，则跳过\r\nif (!requestOrigin) {\r\n  return await next();\r\n}\r\n\r\n// 设置响应头\r\nctx.set('Access-Control-Allow-Origin', requestOrigin)\r\n```\r\n\r\n>  相关问题：[如何避免 CDN 为 PC 端缓存移动端页面](https://github.com/shfshanyue/Daily-Question/issues/330)",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTQ0ODg0NjQ=",
    "number": 365,
    "title": "【Q360】localhost 与 127.0.0.1 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NjUyMDM1Ng==",
      "body": "localhost 可以更改后指向其它地址。\r\n127.0.0.1 是约定的本机IP。\r\n类似互联网中域名与服务器IP的关系。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "hedongxiaoshimei",
        "url": "https://github.com/hedongxiaoshimei"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTQ1NzUyMDE=",
    "number": 366,
    "title": "【Q361】既然 cors 配置可以做跨域控制，那可以防止 CSRF 攻击吗 ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NjY5NzU2Nw==",
      "body": "**对 CORS 一点用也没有**\r\n\r\n1. **`form` 提交不通过 `CORS` 检测**，你可以在本地进行测试\r\n1.  即使通过 `xhr` 及 `fetch` 进行提交被 CORS 拦住，**但是对于简单请求而言，请求仍被发送**，已造成了攻击\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTU3ODEwMjg=",
    "number": 367,
    "title": "【Q362】js 动画和 css 动画那个性能比较好",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NTU3ODM0NDM=",
    "number": 368,
    "title": "【Q363】如何获取当前系统中的在线用户数 (并发用户数)",
    "body": "一些 SaaS 系统基于 Pricing 的考虑，会限制团队人数及同时在线数，如何实现",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY1NzUxMzc5Mw==",
      "body": "> 一些 SaaS 系统基于定价策略的考虑，会限制团队人数及同时在线数，如何实现？\r\n\r\n通过 `redis` 的 `zset` 可实现并发用户数。\r\n\r\n当一个用户请求任何接口时，实现一个 middleware，处理以下逻辑\r\n\r\n``` js\r\n// 当一个用户访问任何接口时，对该用户Id，写入 zset\r\nawait redis.zadd(`Organization:${organizationId}:concurrent`, Date.now(), `User:${userId}`)\r\n\r\n// 查询当前机构的并发数\r\n// 通过查询一分钟内的活跃用户来确认并发数，如果超过则抛出特定异常\r\nconst activeUsers = await redis.zrangebyscore(`Organization:${organizationId}:concurrent`, Date.now() - 1000 * 60, Date.now())\r\n\r\n// 查出并发数\r\nconst count = activeUsers.length\r\n\r\n// 删掉过期的用户\r\nawait redis.zrembyscore(`Organization:${organizationId}:concurrent`, Date.now() - 1000 * 60, Date.now())\r\n```\r\n\r\n## 总结\r\n\r\n1. 每当用户访问服务时，把该用户的 ID 写入优先级队列，权重为当前时间\r\n1. 根据权重(即时间)计算一分钟内该机构的用户数\r\n1. 删掉一分钟以上过期的用户\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NTk4Njk1NTk=",
    "number": 369,
    "title": "【Q364】css 如何匹配前N个子元素及最后N个子元素",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2MDQxODQwNA==",
      "body": "见 [【Q307】如何实现表格单双行条纹样式](https://github.com/shfshanyue/Daily-Question/issues/309)\r\n\r\n+ 如何匹配最前三个子元素: `:nth-child(-n+3)`\r\n+ 如何匹配最后三个子元素: `:nth-last-child(-n+3)`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NjM1NjM3NTM=",
    "number": 370,
    "title": "【Q365】node 中 nextTick 与 setTimeout 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Njg4MTI1Nzc=",
    "number": 371,
    "title": "【Q366】如何保存数据库与缓存的双写一致性",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      },
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Njk0OTUzMTE=",
    "number": 372,
    "title": "【Q367】redux 和 mobx 有什么不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Njk1NjkyMzQ=",
    "number": 373,
    "title": "【Q368】关于 React hooks 的 caputre value，以下输出多少",
    "body": "``` js\r\nfunction App() {\r\n  const [count, setCount] = useState(0);\r\n  const incr = () => {\r\n    setTimeout(() => {\r\n      setCount(count + 1);\r\n    }, 3000);\r\n  };\r\n  return <h1 onClick={incr}>{count}</h1>;\r\n}\r\n```\r\n\r\n当连续点击 10 次时，会输出多少",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczODUyMTA3OA==",
      "body": "应该是1吧，在state被update之前count一直还是0",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "zckpp",
        "url": "https://github.com/zckpp"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Njk2MjU4MTY=",
    "number": 374,
    "title": "【Q369】在 React 项目中 immutable 是优化性能的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Njk5NDE0NzQ=",
    "number": 375,
    "title": "【Q370】如何使用 CSS 实现网站的暗黑模式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
        "name": "css"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Njk5NDgzNTg=",
    "number": 376,
    "title": "【Q371】在 redux 中如何发送请求",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzAzODU1NTE=",
    "number": 377,
    "title": "【Q372】redis 是如何删掉过期数据的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzA0NzM1NDE=",
    "number": 378,
    "title": "【Q373】如何为你们的前端项目选择状态管理器",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzA5MTA1MDE=",
    "number": 379,
    "title": "【Q374】简单介绍 requestIdleCallback 及使用场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2ODA0ODk4MQ==",
      "body": "`requestIdleCallback` 维护一个队列，将在浏览器空闲时间内执行。它属于 [Background Tasks API](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)，你可以使用 `setTimeout` 来模拟实现\r\n\r\n``` js\r\nwindow.requestIdleCallback = window.requestIdleCallback || function(handler) {\r\n  let startTime = Date.now();\r\n \r\n  return setTimeout(function() {\r\n    handler({\r\n      didTimeout: false,\r\n      timeRemaining: function() {\r\n        return Math.max(0, 50.0 - (Date.now() - startTime));\r\n      }\r\n    });\r\n  }, 1);\r\n}\r\n```\r\n\r\n以上实现过于复杂以及细节化，也可以像 [swr](https://github.com/vercel/swr) 一样做一个简单的模拟实现，以下代码见 <https://github.com/vercel/swr/blob/8670be8072b0c223bc1c040deccd2e69e8978aad/src/use-swr.ts#L33>\r\n\r\n``` js\r\nconst rIC = window['requestIdleCallback'] || (f => setTimeout(f, 1))\r\n```\r\n\r\n在 `rIC` 中执行任务时需要注意以下几点：\r\n\r\n1. 执行重计算而非紧急任务\r\n1. 空闲回调执行时间应该小于 50ms，最好更少\r\n1. 空闲回调中不要操作 DOM，因为它本来就是利用的重拍重绘后的间隙空闲时间，重新操作 DOM 又会造成重拍重绘\r\n\r\nReact 的时间分片便是基于类似 `rIC` 而实现，然而因为 `rIC` 的兼容性及 50ms 流畅问题，React 自制了一个实现: [scheduler](https://github.com/facebook/react/tree/master/packages/scheduler)\r\n\r\n[use-swr](https://github.com/vercel/swr) 中进行资源的 `revalidate` 时，也是通过 `rIC` 来提高性能\r\n\r\n## 参考\r\n\r\n**强烈推荐 MDN 与 w3c 上的两篇介绍**\r\n\r\n+ [Background Tasks API - MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)\r\n+ [requestIdleCallback - W3C](https://w3c.github.io/requestidlecallback/#idle-periods)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzE2MzgwNjI=",
    "number": 380,
    "title": "【Q375】在 redux 中如何写一个记录状态变更的日志插件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzE2MzgzNzA=",
    "number": 381,
    "title": "【Q376】TCP 四次挥手时为什么需要 2MSL",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2ODk0MDc5OA==",
      "body": "**我们先来看看什么是 2MSL ？**\r\nMSL: Maximum Segment Lifetime, 最长报文段寿命\r\n意思是，需要等候 2 * MSL 时间，才会进入关闭状态\r\n\r\n\r\n------------\r\n\r\n\r\n**然后再来看哪个阶段需要 2MSL ？**\r\n\r\n![image](https://user-images.githubusercontent.com/8110936/89364080-470b8600-d704-11ea-9bc7-edd882481c1e.png)\r\n从上图来看，是在 [发送方] 发送完 ACK 后，进入 **TIME_WAIT** 阶段，这个阶段需要等候 2*MSL，才将 TCP 关闭\r\n\r\n------------\r\n\r\n**为什么要等候 2*MSL ？**\r\n\r\n1. 用足够长的等候时间，来确保 [接收方] 能收到 ACK 包\r\n\r\n\t- 如果 [接收方] 在一定时间没收到 (ACK)，会重发 (FIN, ACK)，[发送方] 收到后，会重发 (ACK)，再重置 2*MSL 定时器\r\n\t.\r\n\r\n\r\n2. 防止当前连接延迟到达的数据段，被新的 TCP 连接收到\r\n\r\n\t- 新的 TCP 连接：相同端口，相同地址\r\n\r\n\r\n------------\r\n\r\n**TIME_WAIT 等候时间长短问题**\r\n\r\n1. 等候时间过短\r\n \r\n\t- 可能会收到上一个 TCP 连接延迟到达的数据段\r\n\t.\r\n\r\n2. 等候时间过长\r\n\r\n \t- TCP 连接一直占用着端口，需要关闭后才能建立新的连接，高并发下压力比较大\r\n\r\n",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "zzetao",
        "url": "https://github.com/zzetao"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzE3NTQ0NTE=",
    "number": 382,
    "title": "【Q377】在 js 中如何实现继承",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4NzUwNjIzMQ==",
      "body": "有以下两种方法可实现继承\r\n\r\n## `class`/`extends`\r\n\r\n``` js\r\nclass Animal {\r\n  constructor (name) {\r\n    this.name = name\r\n  }\r\n\r\n  hello () {\r\n    console.log('hello')\r\n  }\r\n}\r\n\r\nclass Dog extends Animal {\r\n  constructor (name, say) {\r\n    super(name)\r\n    this.say = say\r\n  }\r\n}\r\n```\r\n\r\n## `function`/`new`\r\n\r\n``` js\r\nfunction Animal (name) {\r\n  this.name = name\r\n}\r\n\r\nAnimal.prototype.hello = () => {\r\n  console.log('hello')\r\n}\r\n\r\nfunction Dog (name, say) {\r\n  // 01 继承属性\r\n  Animal.call(this, name)\r\n  this.say = say\r\n}\r\n\r\n// 02 通过连接原型链完成继承\r\nDog.prototype = Object.create(Animal.prototype)\r\n\r\n// 03 再加上 constructor\r\nDog.prototype.constructor = Dog\r\n// Reflect.defineProperty(Dog.prototype, \"constructor\", {\r\n//  value: Dog,\r\n//  enumerable: false, // 不可枚举\r\n//  writable: true\r\n// })\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzIwOTEzNDI=",
    "number": 383,
    "title": "【Q378】在 setState 时发生了什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyMDg3MTg1OA==",
      "body": "react16\r\n1.setstae 以后会把update队列加入到mount 里面 如果他在生命周期里面 其实他是进行批量去更新的 如果他是在生命周期里面去set 其实数据同步的。如果想要拿到最新的就需要脱离react生命周期，和react事件流 比如在setTimeout里面set值 他拿到的数据就是最新的。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "hqylss111",
        "url": "https://github.com/hqylss111"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI3MzYwMTU=",
    "number": 384,
    "title": "【Q379】你们的后端项目的数据库索引做了哪些优化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzI3MzcyNjM=",
    "number": 385,
    "title": "【Q380】如何设计一个UI组件库",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      },
      {
        "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
        "name": "vue"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzI3Mzc3Njc=",
    "number": 386,
    "title": "【Q381】什么是覆盖索引",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2ODY3NjUxMw==",
      "body": "假设一个用户表 `User(id primary, name unique, age)`，此时 name 为唯一索引。\r\n\r\n聚合索引: `select * from User where id in (1, 2, 3, 4, 5)`，由于 id 都在 `B+ tree` 的叶子节点，不需要去磁盘进一步 IO，称作聚合索引\r\n\r\n假设有一个需求: 根据 name 查询该人对应的 age，在现有情况下是这样的：\r\n\r\n1. 根据 name 上的 `B+ tree` 快速找到该行对应的 id\r\n1. 根据 id 上的 `B+ tree` 快速找到该行对应的 age，此时需要通过主键 id 进一步 IO，称作回表\r\n\r\n**如果建立一个联合索引 (name, age)，直接在 name 上的 `B+ tree` 就可以找到它对应的 age，省了回表操作，称为覆盖索引**",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI4MTg0Mzg=",
    "number": 387,
    "title": "【Q382】你有没有造过轮子",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzI5MDExNDM=",
    "number": 388,
    "title": "【Q000】你最近学习了哪些新技术",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY2OTA1NzU0OA==",
      "body": "##  20200804\r\n\r\n今天看到了 `tailwindcss`，感觉贼好用，很喜欢。基本上是 `class 即 style`，相比 `css modules`，`style-jsx`，可以说是更高层的抽象。虽然从 `bootstrap` 既可以看到这种雏形，但是 `tailwindcss` 做的更彻底，与现代框架集成的也更好\r\n\r\n<https://tailwindcss.com/docs/installation/>\r\n\r\n## 20200805\r\n\r\n`next.js` 最近升级到了 `v9.5.0`，已正式支持了 `custom-routes` 的配置文件写法，详情可以参考文档 [Next.js rewrites](https://nextjs.org/docs/api-reference/next.config.js/rewrites)。而在以前，只能在 `server.js` 中使用 `koa/express` 进行路由拦截来达成目的。\r\n\r\n有时原理虽说比较重要，但此时往往忽略了 API Design 的重要性，假设你要设计一个 Route 的 rewrite/redirect，你会怎么设计 API？可以参考 `nginx`、`koa-routes`、`react-routes` 等\r\n\r\n由于 `next.js` 升级，因为也升级了我的 `next app` 的模板: <https://github.com/shfshanyue/next-app>\r\n\r\n<https://github.com/vercel/next.js/releases/tag/v9.5.0>",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzI5MDM3MTE=",
    "number": 389,
    "title": "【Q384】python 中的 self 与 javascript 中的 this 有何不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzQzNzUzNzU=",
    "number": 390,
    "title": "【Q385】什么是缓存穿透，如何解决",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3MDgzNDY3NQ==",
      "body": "**当访问数据库中不存在的数据时，此时由于不恰当的缓存策略，每次查询都会穿透缓存打在数据库上，这样在高并发下可能造成缓存穿透**，此时的解决方案：\r\n\r\n1. 当应用访问缓存不存在时，应用继续去访问数据库，即便数据库中不存在数据，此时应用再在缓存中把该值设为空，过期时间以短时间为主\r\n1. 使用过滤器做进一步的过滤，如redis 中的 bitmap 或 set，当不存在该值时，直接返回",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzQzNzYwMjk=",
    "number": 391,
    "title": "【Q386】什么是浏览器的关键渲染路径",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3MDAwNTAzMQ==",
      "body": "## 01 DOM\r\n\r\n生成 DOM 会从远程下载 Byte，并根据相应的编码 (如 `utf8`) 转化为字符串，通过 AST 解析为 Token，生成 Node 及最后的 DOM。\r\n\r\n> 以下图片来自于 [构建 OM - Google Developers](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model)\r\n\r\nAST 解析过程可以查看 <https://astexplorer.net/>\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/89550597-63124300-d83c-11ea-971d-fcdc0ed9fed2.png)\r\n\r\n可以通过 devtools 中查看该过程\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/89658346-03ca3680-d901-11ea-9a49-9cf36cf651f0.png)\r\n\r\n## 02 CSSOM\r\n\r\n当解析 CSS 文件时，最终会生成 CSSOM\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/89551525-a1f4c880-d83d-11ea-96f2-8b01366e7045.png)\r\n\r\n## 03 Render Tree\r\n\r\nDOM 与 CSSOM 会一起生成 Render Tree，只包含渲染网页所需的节点。\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/89551568-ad47f400-d83d-11ea-9585-e24dd3c0ab3d.png)\r\n\r\n## 04 Layout\r\n\r\n计算每一个元素在设备视口内的确切位置和大小\r\n\r\n> 以下图片来自于 [关键渲染路径 - 掘金](https://juejin.im/post/6844903756820119560)\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/89703579-9d83f900-d97e-11ea-82b2-7528c8426c8f.png)\r\n\r\n## 05 Paint\r\n\r\n将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/89663916-ec8f4700-d908-11ea-8e6b-4083793cff1a.png)\r\n\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzQ0MDk5Nzk=",
    "number": 392,
    "title": "【Q387】http2 中 server push 与 websocket 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxNTkzOTU0MQ==",
      "body": "+ HTTP2 Server Push，一般用以服务器根据解析 `index.html` 同时推送 `JPG/JS/CSS` 等资源，而免了服务器发送多次请求\r\n+ websocket，用以服务器与客户端手动编写代码去推送进行数据通信",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzUxMjY1NTU=",
    "number": 393,
    "title": "【Q388】简述下 TLS 握手过程",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3MjkxMTU1OQ==",
      "body": "TLS 握手的详细过程可参考下图：\r\n\r\n![TLS handshake](https://www.oreilly.com/library/view/high-performance-browser/9781449344757/images/hpbn_0402.png)\r\n\r\n> 以上图片来自 [high-performance-browser](https://www.oreilly.com/library/view/high-performance-browser/9781449344757/ch04.html)\r\n\r\n从 `wireshark` 抓包，也可以看到握手的详细流程，建议抓包加强理解，以下是抓包 `https://q.shanyue.tech` 时的握手流程\r\n\r\n通过 `curl -vvv --head` 来查看握手信息:\r\n\r\n``` bash\r\n$ curl -vvv --head  https://q.shanyue.tech\r\n*   Trying 111.6.180.235...\r\n* TCP_NODELAY set\r\n* Connected to q.shanyue.tech (111.6.180.235) port 443 (#0)\r\n* ALPN, offering h2\r\n* ALPN, offering http/1.1\r\n* successfully set certificate verify locations:\r\n*   CAfile: /etc/ssl/cert.pem\r\n  CApath: none\r\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\r\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\r\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\r\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\r\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\r\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\r\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\r\n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\r\n* TLSv1.2 (IN), TLS handshake, Finished (20):\r\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256\r\n* ALPN, server accepted to use h2\r\n* Server certificate:\r\n*  subject: CN=q.shanyue.tech\r\n*  start date: Dec  2 00:00:00 2019 GMT\r\n*  expire date: Dec  1 12:00:00 2020 GMT\r\n*  subjectAltName: host \"q.shanyue.tech\" matched cert's \"q.shanyue.tech\"\r\n*  issuer: C=US; O=DigiCert Inc; OU=www.digicert.com; CN=Encryption Everywhere DV TLS CA - G1\r\n*  SSL certificate verify ok.\r\n* Using HTTP2, server supports multi-use\r\n* Connection state changed (HTTP/2 confirmed)\r\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\r\n* Using Stream ID: 1 (easy handle 0x7f95ba80dc00)\r\n\r\n``` \r\n\r\n## 握手过程\r\n\r\n在 TLS 1.2 中，握手协议过程需要耗费两个 RTT，过程如下\r\n\r\n1. [OUT] Client Hello，客户端选出自身支持的 TLS 版本号、`cipher suites`、一个随机数、SessionId 传送给服务器端 (有可能可服用 Session)\r\n1. [IN] Server Hello，服务器端选出双方都支持的 TLS 版本，`cipher suite` 、一个随机数、SeesionId 给客户端\r\n1. [IN] Certificate，服务器端给客户端发送证书，用以身份验证及提供公钥\r\n1. [IN] Server Key Exchange，服务器端给客户端发送秘钥交换算法的一些参数\r\n1. [IN] Server Finished\r\n1. [OUT] Client Key Exchange，客户端给服务器端发送秘钥交换算法的一些参数，计算出预备主密钥 (pre master key)，作为随机数传递给服务器端 (这个随机数是安全的)。双方根据三个随机数生成对称加密中的秘钥\r\n1. [OUT] Change Cipher Spec，告知对方以后的消息将要使用TLS记录层协议进行加密\r\n1. [OUT] Finished，发送第一条加密的消息并完整性验证\r\n1. [IN] Change Cipher Spec，告知以后的消息将要使用TLS记录层协议进行加密\r\n1. [IN] Finished，发送第一条加密的消息并完整性验证\r\n\r\n## 相关链接\r\n\r\n+ [https握手流程详解](https://juejin.im/post/6844904135230390279#heading-10)\r\n+ [Chapter 4. Transport Layer Security (TLS)](https://www.oreilly.com/library/view/high-performance-browser/9781449344757/ch04.html)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2NzU5NTIyMTk=",
    "number": 396,
    "title": "【Q389】以下输出顺序多少 (setTimeout 与 promise 顺序)",
    "body": "``` js\r\nsetTimeout(() => console.log(0))\r\nnew Promise((resolve) => {\r\n  console.log(1)\r\n  resolve(2)\r\n  console.log(3)\r\n}).then(o => console.log(o))\r\n\r\nnew Promise(resolve => {\r\n  console.log(4)\r\n  resolve(5)\r\n}).then(o => console.log(o)).then(() => console.log(6))\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3MTQxNTAyMw==",
      "body": "1 => 3 => 4 => 2 => 5 => 6 => 0",
      "reactions": {
        "totalCount": 1
      },
      "author": null
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzc4MDY4MTU=",
    "number": 397,
    "title": "【Q390】简单介绍一下 RSA 算法",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
        "name": "network"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Nzg1NDE4NDE=",
    "number": 398,
    "title": "【Q391】https 层可以做哪些性能优化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3MzU2MzE1Mg==",
      "body": "<https://time.geekbang.org/column/article/111287>",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzg1NTEzMjM=",
    "number": 399,
    "title": "【Q392】ECDHE 与 RSA 有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzkxOTc4NDI=",
    "number": 400,
    "title": "【Q393】作为 TL 如何管理团队",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2NzkyMzk1Njc=",
    "number": 401,
    "title": "【Q394】https 中证书的格式化信息有哪些",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3ODY0OTQ3Ng==",
      "body": "在 TLS 握手过程中，服务器端需要给客户端提供证书，**X.509 就是证书的标准格式。**\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/90958724-cbae2080-e4c8-11ea-996e-3257721c89fc.png)\r\n\r\n以下是 github 的证书在 Mac 上显示的内容，可见：\r\n\r\n1. 序列号\r\n1. Subject Name\r\n1. Issuer Name\r\n1. 电子签名\r\n1. 签名算法\r\n1. 公钥\r\n1. 扩展\r\n\r\n\r\n\r\n## 相关链接\r\n\r\n+ [What Is an X.509 Certificate?](https://www.ssl.com/faqs/what-is-an-x-509-certificate/)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzk0ODQ5NTg=",
    "number": 402,
    "title": "【Q395】https 连接时如何保证证书没被废弃掉",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3NDQxNDI4OQ==",
      "body": "两种方式：\r\n\r\n1. CRL（Certificate Revocation List，证书撤销名单）。PKI 体系中由 CA 维护的一个被撤销证书的列表，浏览器会定时拉取这个文件。但这个文件的实时性及性能都可能有问题\r\n1. OCSP（Online Certificate Status Protocol，在线证书状态协议）。客户端通过 OSCP 服务请求接口来判断某个证书是否有效",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzk0ODcxNjU=",
    "number": 403,
    "title": "【Q396】TLS1.3 相比 TLS1.2 有何不同",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3NTIxNDAwMQ==",
      "body": "以下摘自 [RFC 5246: TLS 1.2](https://tools.ietf.org/html/rfc5246#section-7.3)\r\n\r\n``` txt\r\n      Client                                               Server\r\n\r\n      ClientHello                  -------->\r\n                                                      ServerHello\r\n                                                     Certificate*\r\n                                               ServerKeyExchange*\r\n                                              CertificateRequest*\r\n                                   <--------      ServerHelloDone\r\n      Certificate*\r\n      ClientKeyExchange\r\n      CertificateVerify*\r\n      [ChangeCipherSpec]\r\n      Finished                     -------->\r\n                                               [ChangeCipherSpec]\r\n                                   <--------             Finished\r\n      Application Data             <------->     Application Data\r\n\r\n             Figure 1.  Message flow for a full handshake\r\n\r\n   * Indicates optional or situation-dependent messages that are not\r\n   always sent.\r\n```\r\n\r\n以下摘自 [RFC 8446: TLS 1.3](https://tools.ietf.org/html/rfc8446)\r\n\r\n``` txt\r\n       Client                                           Server\r\n\r\nKey  ^ ClientHello\r\nExch | + key_share*\r\n     | + signature_algorithms*\r\n     | + psk_key_exchange_modes*\r\n     v + pre_shared_key*       -------->\r\n                                                  ServerHello  ^ Key\r\n                                                 + key_share*  | Exch\r\n                                            + pre_shared_key*  v\r\n                                        {EncryptedExtensions}  ^  Server\r\n                                        {CertificateRequest*}  v  Params\r\n                                               {Certificate*}  ^\r\n                                         {CertificateVerify*}  | Auth\r\n                                                   {Finished}  v\r\n                               <--------  [Application Data*]\r\n     ^ {Certificate*}\r\nAuth | {CertificateVerify*}\r\n     v {Finished}              -------->\r\n       [Application Data]      <------->  [Application Data]\r\n\r\n              +  Indicates noteworthy extensions sent in the\r\n                 previously noted message.\r\n\r\n              *  Indicates optional or situation-dependent\r\n                 messages/extensions that are not always sent.\r\n\r\n              {} Indicates messages protected using keys\r\n                 derived from a [sender]_handshake_traffic_secret.\r\n\r\n              [] Indicates messages protected using keys\r\n                 derived from [sender]_application_traffic_secret_N.\r\n\r\n               Figure 1: Message Flow for Full TLS Handshake\r\n\r\n```\r\n\r\n1. 握手时间从以前的 2RTT 缩短到 1RTT，通过 `Pre shared-key` 减少了单独的 ServerKeyExchange 与 ClientKeyExchange 消耗的一个 RTT\r\n1. 0-RTT Resumption",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2Nzk3NTMzNjY=",
    "number": 404,
    "title": "【Q397】什么是 oauth2，它解决了什么问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2Nzk3NTQwMTk=",
    "number": 405,
    "title": "【Q398】在 wireshark 中如何抓包 https ",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODA2NTIzODA=",
    "number": 406,
    "title": "【Q399】实现一个 once 函数，记忆返回结果只执行一次",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3NTUxOTA0NQ==",
      "body": "简单实现如下：\r\n\r\n``` js\r\nfunction once (f) {\r\n  let result\r\n  let revoked = false\r\n  \r\n  return (...args) => {\r\n    if (revoked) return result\r\n    const r = f(...args)\r\n    revoked = true\r\n    result = r\r\n    return r\r\n  }\r\n}\r\n```\r\n\r\n``` js\r\n> const f = () => {console.log('call'); return 3;}\r\n< undefined\r\n\r\n> once_f = once(f)\r\n< (...args) => {\r\n    if (revoked) return result\r\n    const r = f(...args)\r\n    revoked = true\r\n    result = r\r\n  }\r\n\r\n// 第一次调用\r\n> once_f()\r\n< call\r\n< 3\r\n\r\n// 第二次调用，没有打印 call\r\n> once_f()\r\n< 3\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODA2NjM1NDg=",
    "number": 407,
    "title": "【Q400】如何评估一台服务器的 CPU 性能",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3ODcxNzQxMg==",
      "body": "## sysbench\r\n\r\n``` bash\r\n$ sysbench --threads=4 --time=30 cpu run\r\n\r\nsysbench 1.0.17 (using system LuaJIT 2.1.0-beta3)\r\n\r\nRunning the test with following options:\r\nNumber of threads: 4\r\nInitializing random number generator from current time\r\n\r\n\r\nPrime numbers limit: 10000\r\n\r\nInitializing worker threads...\r\n\r\nThreads started!\r\n\r\nCPU speed:\r\n    events per second:  3651.16\r\n\r\nGeneral statistics:\r\n    total time:                          30.0010s\r\n    total number of events:              109545\r\n\r\nLatency (ms):\r\n         min:                                    1.08\r\n         avg:                                    1.10\r\n         max:                                    5.78\r\n         95th percentile:                        1.12\r\n         sum:                               119955.35\r\n\r\nThreads fairness:\r\n    events (avg/stddev):           27386.2500/91.56\r\n    execution time (avg/stddev):   29.9888/0.00\r\n```\r\n\r\n## stress",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODEwNjA3NjY=",
    "number": 408,
    "title": "【Q401】在 TLS 层如何优化网站性能",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3OTk0MzYzNg==",
      "body": "1. OSCP Stapling\r\n1. TLS 1.3",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODE1OTE1NDk=",
    "number": 409,
    "title": "【Q402】如何实现一个函数 isPlainObject 判断是否为纯对象",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3NTk1MTQzOA==",
      "body": "``` js\r\nfunction isPlainObject(obj: any): boolean {\r\n  if (typeof obj !== 'object' || obj === null) return false\r\n\r\n  let proto = obj\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto)\r\n  }\r\n\r\n  return Object.getPrototypeOf(obj) === proto                                                  } \r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODE3MzAzOTM=",
    "number": 410,
    "title": "【Q403】React 中的 dom diff 算法如何从 O(n3) 优化到 O(n) 的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODI2MTk1MDM=",
    "number": 411,
    "title": "【Q404】在 React 应用中如何排查性能问题",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODI4NTI0NDc=",
    "number": 412,
    "title": "【Q405】你使用过哪些前端性能分析工具",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3ODEyMDQ1OA==",
      "body": "chrome 自带的灯箱",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "zxhycxq",
        "url": "https://github.com/zxhycxq"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODMyMTk5NzM=",
    "number": 413,
    "title": "【Q406】在你们的后端应用中，redis 用在哪些场景",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
        "name": "redis"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3ODcxNDk3NA==",
      "body": "1. 缓存\r\n1. 限流\r\n1. 队列\r\n1. 分布式锁\r\n1. 并发数控制\r\n1. bitmap\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODQxMTQ1ODU=",
    "number": 414,
    "title": "【Q407】什么是 CPU 缓存，如何查看缓存命中率",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      },
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNDYwNTYyNg==",
      "body": "CPU 缓存介于 CPU 和内存之间，缓存的是热点的内存数据。这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 在同一个cpu核中， 而在同一个CPU插槽中的多个核共享一个 L3 缓存。\r\n\r\n缓存命中率，即直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。当可以直接通过缓存获取到需要的数据，则命中缓存；否则需要从磁盘等地方读取获取数据。缓存命中率越高，表示直接从缓存获取数据的次数越多，程序执行效率越高。\r\n使用cachestat 可以查看整个个操作系统缓存的读写命中情况：\r\ncachestat安装方式：\r\n`sudo apt install perf-tools-unstable`\r\n\r\n下面以1秒间隔输出三组缓存信息：\r\n```\r\n$ sudo cachestat 1\r\nCounting cache functions... Output every 1 seconds.\r\n    HITS   MISSES  DIRTIES    RATIO   BUFFERS_MB   CACHE_MB\r\n    1989        0       13   100.0%          501       2600\r\n   12969        0     1412   100.0%          501       2600\r\n   16798        0     2803   100.0%          501       2600\r\n```\r\n从结果可以看到，HITS 是缓存命中的次数；MISSES是缓存未命中的次数；DIRTIES是表示新增到缓存中的脏页数；BUFFERS_MB 表示 Buffers 的大小，单位为MB；CACHED_MB表示Cache 的大小，单位为MB。\r\n",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "wangedison",
        "url": "https://github.com/wangedison"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODQxODc1NjA=",
    "number": 415,
    "title": "【Q408】React 17.0 有什么变化",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
        "name": "react"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODQxOTQxNDE=",
    "number": 416,
    "title": "【Q409】什么是 BNF 与 ABNF",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY5Njc1NDg2OQ==",
      "body": "`BNF` (巴克斯范式) 是一种描述编程语言语法的元语言\r\n\r\n`ABNF` (Augmented BNF)，扩展的 BNF，通过 <https://www.ietf.org/rfc/rfc5234.txt> 规范",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODQ1MDY3OTI=",
    "number": 417,
    "title": "【Q410】你最近看的三本书是什么",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
        "name": "open"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODUwNzY3MDM=",
    "number": 418,
    "title": "【Q411】如何找到当前页面出现次数最多的HTML标签",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
        "name": "html"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MDQxNjkxNw==",
      "body": "这是一道前端基础与编程功底具备的面试题：\r\n\r\n+ 如果你前端基础强会了解 `document.querySelector(*)` 能够列出页面内所有标签\r\n+ 如果你编程能力强能够用递归快速实现同等的效果\r\n\r\n有三种 API 可以列出页面所有标签：\r\n\r\n1. `document.querySelector('*')`，标准规范实现\r\n1. `$$('*')`，devtools 实现\r\n1. `document.all`，非标准规范实现\r\n\r\n``` js\r\n> document.querySelectorAll('*')\r\n< NodeList(593) [html, head, meta, meta, meta, meta, meta, meta, meta, title, link#favicon, link, link#MainCss, link#mobile-style, link, link, link, script, script, script, script, script, script, script, link, script, link, link, script, input#_w_brink, body, a, div#home, div#header, div#blogTitle, a#lnkBlogLogo, img#blogLogo, h1, a#Header1_HeaderTitle.headermaintitle.HeaderMainTitle, h2, div#navigator, ul#navList, li, a#blog_nav_sitehome.menu, li, a#blog_nav_myhome.menu, li, a#blog_nav_newpost.menu, li, a#blog_nav_contact.menu, li, a#blog_nav_rss.menu, li, a#blog_nav_admin.menu, div.blogStats, span#stats_post_count, span#stats_article_count, span#stats-comment_count, div#main, div#mainContent, div.forFlow, div#post_detail, div#topics, div.post, h1.postTitle, a#cb_post_title_url.postTitle2.vertical-middle, span, div.clear, div.postBody, div#cnblogs_post_body.blogpost-body, p, p, strong, p, p, p, strong, div.cnblogs_code, pre, span, span, span, span, span, p, span, strong, pre, strong, span, strong, br, br, br, div.cnblogs_code, pre, span, span, p, p, …]\r\n[0 … 99]\r\n[100 … 199]\r\n[200 … 299]\r\n[300 … 399]\r\n[400 … 499]\r\n[500 … 592]\r\n__proto__: NodeList\r\n```\r\n\r\n使用 `document.querySelectorAll` 实现如下\r\n\r\n``` js\r\nconst maxBy = (list, keyBy) => list.reduce((x, y) => keyBy(x) > keyBy(y) ? x : y)\r\n\r\nfunction getFrequentTag () {\r\n  const tags = [...document.querySelectorAll('*')].map(x => x.tagName).reduce((o, tag) => { \r\n    o[tag] = o[tag] ? o[tag] + 1 : 1;\r\n    return o\r\n  }, {})\r\n  return maxBy(Object.entries(tags), tag => tag[1])\r\n}\r\n```\r\n\r\n使用 `element.children` 递归迭代如下 (最终结果多一个 document)\r\n\r\n``` js\r\nfunction getAllTags(el = document) {\r\n  const children = Array.from(el.children).reduce((x, y) => [...x, ...getAllTags(y)], [])\r\n  return children\r\n}\r\n\r\n// 或者通过 flatMap 实现\r\nfunction getAllTags(el = document) {\r\n  const children = Array.prototype.flatMap.call(el.children, x => getAllTags(x))\r\n  return [el, ...children]\r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUwNzg4ODk=",
    "number": 419,
    "title": "【Q412】对以下字符进行压缩编码",
    "body": "这是一道大厂常考的代码题\r\n\r\n+ Input: 'aaaabbbccd'\r\n+ Output: 'a4b3c2d1'，代表 a 连续出现四次，b连续出现三次，c连续出现两次，d连续出现一次",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
        "name": "algorithm"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3OTYyNjgzMw==",
      "body": "编写函数 `encode` 实现该功能\r\n\r\n``` js\r\nfunction encode (str) {\r\n  const l = []\r\n  let i = 0\r\n  for (const s of str) {\r\n    const len = l.length\r\n    const lastChar = len > 0 ? l[len - 1][0] : undefined\r\n    if (lastChar === s) {\r\n      l[len - 1][1]++\r\n    } else {\r\n      l.push([s, 1])\r\n    }\r\n  }\r\n  return l.map(x => x.join('')).join('')\r\n}\r\n```\r\n\r\n测试通过\r\n\r\n``` js\r\n> encode('aaab')\r\n< \"a3b1\"\r\n```\r\n\r\n但是面试官往往会继续深入\r\n\r\n1. 如果只出现一次，不编码数字，如 `aaab -> a3b`\r\n1. 如果只出现两次，不进行编码，如 `aabbb -> aab3`\r\n1. 如果进行解码",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUwODAzMjA=",
    "number": 420,
    "title": "【Q413】如何在生产环境部署一个 Node 应用",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
        "name": "devops"
      },
      {
        "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
        "name": "node"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODUxMDM5Njg=",
    "number": 421,
    "title": "【Q414】git 如何添加与删除一个 submodule",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
        "name": "git"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY3OTYxOTEwMQ==",
      "body": "**添加 submodule**\r\n\r\n``` bash\r\n$ git submodule add :git-url dep\r\n```\r\n\r\n**删除 submodule**\r\n\r\n+ `vim .gitmodules`，找到该模块位置，删掉\r\n+ `vim .git/config`，找到该模块位置，删除\r\n+ `rm -rf .git/module/dep` \r\n+ `git rm --cached dep`",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUxNjQwNTU=",
    "number": 422,
    "title": "【Q415】你有没有重客户端状态前端应用的经验",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODUxNjczMjc=",
    "number": 423,
    "title": "【Q416】apollo-client 与 react-apollo 在前端应用中扮演什么角色",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
        "name": "graphql"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODUyNjE0MzA=",
    "number": 424,
    "title": "【Q417】什么是 exit code",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczODAwODA5Nw==",
      "body": "`exit code` 代表一个进程的返回码，通过系统调用 `exit_group` 来触发。在 `POSIX` 中，`0` 代表正常的返回码，`1-255` 代表异常返回码，一般主动抛出的错误码都是 `1`。\r\n\r\n这里有一张关于异常码的附表 [Appendix E. Exit Codes With Special Meanings](http://www.tldp.org/LDP/abs/html/exitcodes.html)。\r\n\r\n异常码在操作系统中随处可见，以下是一个关于 `cat` 命令的异常以及它的 `exit code`，并使用 `strace` 追踪系统调用。\r\n\r\n``` bash\r\n$ cat a\r\ncat: a: No such file or directory\r\n\r\n# 使用 strace 查看 cat 的系统调用\r\n# -e 只显示 write 与 exit_group 的系统调用\r\n$ strace -e write,exit_group cat a\r\nwrite(2, \"cat: \", 5cat: )                    = 5\r\nwrite(2, \"a\", 1a)                        = 1\r\nwrite(2, \": No such file or directory\", 27: No such file or directory) = 27\r\nwrite(2, \"\\n\", 1\r\n)                       = 1\r\nexit_group(1)                           = ?\r\n+++ exited with 1 +++\r\n```\r\n\r\n从系统调用的最后一行可以看出，该进行的 `exit code` 是 1，并把错误信息输出到 `stderr` (标准错误的 fd 为2) 中\r\n\r\n## 如何查看 exit code\r\n\r\n从 `strace` 中可以来判断进程的 `exit code`，但是不够方便过于冗余，特别身处 shell 编程环境中。\r\n\r\n**有一种简单的方法，通过 `echo $?` 来确认返回码**\r\n\r\n``` bash\r\n$ cat a\r\ncat: a: No such file or directory\r\n\r\n$ echo $?\r\n1\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODUzMjM3ODQ=",
    "number": 425,
    "title": "【Q418】什么是 coredump，如何配置与分析",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
        "name": "linux"
      },
      {
        "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
        "name": "os"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2ODU0Mzc2Nzk=",
    "number": 426,
    "title": "【Q419】DV、OV、EV 类的证书有何区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MzI3OTg2NA==",
      "body": "+ `Domain Validation`，最低级别的证书校验，Lets Encrypt 就是这种，因此也不怎么需要花钱\r\n+ `Organization Validation`，校验证书中组织身份，从中可以看出公司名称，所在地等信息\r\n+ `Extended Validation`，最高级别的证书校验",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODU0ODMzOTE=",
    "number": 427,
    "title": "【Q420】https 中是如何进行身份认证的",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4NzUwNzM3OQ==",
      "body": "电子签名",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODYyNTQyMjA=",
    "number": 428,
    "title": "【Q421】如何实现无限累加的一个函数",
    "body": "实现一个 sum 函数如下所示：\r\n\r\n``` js\r\nsum(1, 2, 3).valueOf() //6\r\nsum(2, 3)(2).valueOf() //7\r\nsum(1)(2)(3)(4).valueOf() //10\r\nsum(2)(4, 1)(2).valueOf() //9\r\nsum(1)(2)(3)(4)(5)(6).valueOf() // 21\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MDgzMzk1NA==",
      "body": "这是一个关于懒计算的函数，使用 `sum` 收集所有累加项，使用 `valueOf` 进行计算\r\n\r\n1. sum 返回一个函数，收集所有的累加项，使用递归实现\r\n1. 返回函数带有 `valueOf` 属性，用于统一计算\r\n\r\n``` js\r\nfunction sum (...args) {\r\n  const f = (...rest) => sum(...args, ...rest)\r\n  f.valueOf = () => args.reduce((x, y) => x + y, 0)\r\n  return f\r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODY4NjEzMTI=",
    "number": 429,
    "title": "【Q422】JS 如何实现一个同步的 sleep 函数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4MTIwMjAyOA==",
      "body": "``` js\r\nconst sleep = ms => Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, milliseconds)\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODY4NjIzODI=",
    "number": 430,
    "title": "【Q423】什么是安全的正则表达式",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcwNjg5OTA4OQ==",
      "body": "下边这个正则表达式能把 CPU 跑挂的正则表达式就是一个定时炸弹，回溯次数进入了指数爆炸般的增长。\r\n\r\n> 可以参考文章 [浅析 ReDos 原理与实践](https://www.freebuf.com/articles/network/124422.html)\r\n\r\n``` js\r\nconst safe = require('safe-regex')\r\nconst re = /(x+x+)+y/\r\n\r\n// 能跑死 CPU 的一个正则\r\nre.test('xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx')\r\n\r\n// 使用 safe-regex 判断正则是否安全\r\nsafe(re)   // false\r\n```\r\n\r\n[safe-regex](https://github.com/substack/safe-regex) 能够发现哪些不安全的正则表达式。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2ODg1Mjc0Nzg=",
    "number": 431,
    "title": "【Q424】TCP 是如何进行流量控制的 (flow control)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
        "name": "tcp"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDY4NzUzNzYwOA==",
      "body": "TCP中存在发送窗口和接受窗口，发送窗口发送的帧需要接受窗口进行接受，接受成功则返回确认应答，如果没有确认应答返回则进行超时重传，流量控制也是依靠这一点，通过控制窗口的大小来实现对传输速率的控制。相应，类似这一点的逻辑还有TCP的慢启动，逐渐扩大窗口大小，来测试出链路的最大传输速率。",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "gmch1",
        "url": "https://github.com/gmch1"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2OTEwNjQzMTM=",
    "number": 432,
    "title": "【Q425】什么是层叠上下文 (stacking context)",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczODAwNDk1NQ==",
      "body": "> 我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。\r\n\r\n其中，`z-index` 会影响这个层级的优先性",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU2OTQzNjU5ODU=",
    "number": 433,
    "title": "【Q426】TCP 报文中的选项 Window scale 是什么意思",
    "body": "![image](https://user-images.githubusercontent.com/13389461/92325971-3f335e80-f081-11ea-8f6e-334d5d9e95f6.png)\r\n",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
        "name": "tcp"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU2OTQzNzQxMzI=",
    "number": 434,
    "title": "【Q427】TCP 报文中的 ack number 如何计算",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMzA5NzM0Njk0",
        "name": "tcp"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU3MDkwNTk1NTA=",
    "number": 435,
    "title": "【Q428】在 nginx 中如何配置负载均衡",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      },
      {
        "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
        "name": "前端工程化"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcwNzA4MDU0OQ==",
      "body": "通过 `proxy_pass` 与 `upstream` 即可实现最为简单的负载均衡。如下配置会对流量均匀地导向 `172.168.0.1`，`172.168.0.2` 与 `172.168.0.3` 三个服务器\r\n\r\n``` conf\r\nhttp {\r\n  upstream backend {\r\n      server 172.168.0.1;\r\n      server 172.168.0.2;\r\n      server 172.168.0.3;\r\n  }\r\n\r\n  server {\r\n      listen 80;\r\n      location / {\r\n          proxy_pass http://backend;\r\n      }\r\n  }\r\n}\r\n```\r\n\r\n关于负载均衡的策略大致有以下四种种\r\n\r\n1. round_robin，轮询\r\n1. weighted_round_robin，加权轮询\r\n1. ip_hash\r\n1. least_conn\r\n\r\n## Round_Robin\r\n\r\n轮询，`nginx` 默认的负载均衡策略就是轮询，假设负载三台服务器节点为 A、B、C，则每次流量的负载结果为 ABCABC\r\n\r\n## Weighted_Round_Robin\r\n\r\n加权轮询，根据关键字 weight 配置权重，如下则平均没来四次请求，会有八次打在 A，会有一次打在 B，一次打在 C\r\n\r\n``` conf\r\nupstream backend {\r\n  server 172.168.0.1 weight=8;\r\n  server 172.168.0.2 weight=1;\r\n  server 172.168.0.3 weight=1;\r\n}\r\n```\r\n\r\n## IP_hash\r\n\r\n对每次的 IP 地址进行 Hash，进而选择合适的节点，如此，每次用户的流量请求将会打在固定的服务器上，利于缓存，也更利于 AB 测试等。\r\n\r\n``` conf\r\nupstream backend {\r\n  server 172.168.0.1;\r\n  server 172.168.0.2;\r\n  server 172.168.0.3;\r\n  ip_hash;\r\n}\r\n```\r\n\r\n## Least Connection\r\n\r\n选择连接数最少的服务器节点优先负载\r\n\r\n``` conf\r\nupstream backend {\r\n  server 172.168.0.1;\r\n  server 172.168.0.2;\r\n  server 172.168.0.3;\r\n  least_conn;\r\n}\r\n```\r\n\r\n说到最后，**这些负载均衡策略对于应用开发者至关重要，而基础开发者更看重如何实现这些策略**，如这四种负载算法如何实现？请参考以后的文章",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3MDkwODUxMzQ=",
    "number": 436,
    "title": "【Q429】实现一个函数用来解析 URL 的 querystring",
    "body": "示例，如\r\n\r\n``` js\r\nconst url = 'https://shanyue.tech?a=3&b=4&c=5'\r\n\r\nconst qs = {\r\n  a: 3,\r\n  b: 4,\r\n  c: 5\r\n}\r\n```",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcwODEzMzUxMg==",
      "body": "一开始`decodeURIComponent(url)`是否不妥，如果query string中的value带有`=`等字符并且已经被`encodeURIComponent`，如`http://example.com?tag=test&title=1%2B1%3D2`中`title=1+1=2`，使用parse解析的结果是错误的。使用`params[k] = decodeURIComponent(v)`是不是更好",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "ly023",
        "url": "https://github.com/ly023"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3MTg4MDAxODc=",
    "number": 437,
    "title": "【Q430】如何把 DOM 转化为图片",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczMDI1MDg5MA==",
      "body": "https://www.zhangxinxu.com/study/201708/svg-foreignobject-dom-to-image.html\r\n看到这样一篇文章",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "markgong-gd",
        "url": "https://github.com/markgong-gd"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3Mjc0NDkxNDg=",
    "number": 438,
    "title": "【Q431】http 状态码 401 和 403 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU3Mjc4ODI0NzY=",
    "number": 439,
    "title": "【Q432】如何给 graphql 设计合理的 Rate Limit",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
        "name": "graphql"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
        "name": "server"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczNzk5ODYyNQ==",
      "body": "对于 Rest API 而言可根据特定的 API 来进行*限流(Rate Limit)*设计\r\n\r\n然而，GraphQL 只有一个 API，无法根据此来限流，一般情况下根据 `Field` 来进行限流，为了更好地设计及声明限流条件，可自定义 `Directive`，如下所示\r\n\r\n``` gql\r\ntype Query {\r\n  todos: [Todo!]! @rateLimit(window: \"1s\", max: 100)\r\n}\r\n```\r\n\r\n可参考以下两个 npm package\r\n\r\n+ [graphql-rate-limit](https://github.com/teamplanes/graphql-rate-limit)\r\n+ [graphql-rate-limit-directive](https://github.com/ravangen/graphql-rate-limit)",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3Mjc5MDU1MzQ=",
    "number": 440,
    "title": "【Q433】在C语言中，void 是什么意思",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
        "name": "c"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxNDkwNzMzOA==",
      "body": "`void`，空的意思，意即无需返回。\r\n\r\n``` c\r\n#include <stdio.h>\r\n\r\nvoid print() {\r\n  puts(\"hello, world\");\r\n  return;\r\n}\r\n\r\nint main() {\r\n  print();\r\n  return 0;\r\n}\r\n```\r\n\r\n代码如上所示: `return` 没有返回任何东西，为其简便可以省略不写，以下两者是等价的\r\n\r\n``` c\r\nvoid print() {\r\n  puts(\"hello, world\");\r\n  return;\r\n}\r\n\r\nvoid print() {\r\n  puts(\"hello, world\");\r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3MzMyNjMxMjI=",
    "number": 441,
    "title": "【Q434】当服务器资源返回 304 时与那些 HTTP 响应头有关",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
        "name": "http"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcxOTYzNTkyNg==",
      "body": "304 Not Modified，表示资源没有发生过改变。\r\n与协商缓存有关，也就是Last-Modify和Etag两个http响应头，在获取资源之前先判断缓存资源是否发生过改变。\r\nno-cache表示使用缓存资源时，都向服务器请求验证。\r\nno-store才表示不使用任何形式的缓存。",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "buzuosheng",
        "url": "https://github.com/buzuosheng"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3MzQxNTU5OTE=",
    "number": 442,
    "title": "【Q435】JS 如何实现一个 sleep/delay 函数",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyNTg2NzU3Nw==",
      "body": "```javascript\r\nfunction delay(time) {\r\n    return new Promise((resolve)=> {\r\n        setTimeout(() => {\r\n            resolve()\r\n        }, time)\r\n    })\r\n}\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "yuuk",
        "url": "https://github.com/yuuk"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NDEyMjEyMjM=",
    "number": 443,
    "title": "【Q436】如何实现一个 sample 函数，从数组中随机取一个元素",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDczMDgzNjY2NQ==",
      "body": "> Math.random() 函数返回一个浮点,  伪随机数在范围从0到小于1，用数学表示就是 [0, 1)，可以利用它来实现 `sample` 函数\r\n\r\n``` js\r\nArray.prototype.sample = function () { return this[Math.floor(Math.random()*this.length)] }\r\n```",
      "reactions": {
        "totalCount": 1
      },
      "author": {
        "login": "shfshanyue",
        "url": "https://github.com/shfshanyue"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NDMwMDA4MzY=",
    "number": 444,
    "title": "【Q437】浏览器的剪切板中如何监听复制事件",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
        "name": "dom"
      },
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": {
      "id": "MDEyOklzc3VlQ29tbWVudDcyOTM0MzcxNw==",
      "body": "在HTML元素上\r\n```html\r\n<input oncopy='cb'>\r\n```\r\n在JS中获取具体元素\r\n```js\r\ndocument.querySelector('p').oncopy = cb\r\ndocument.oncopy = cb\r\n```\r\n或者\r\n```js\r\ndocument.querySelector('p').addEventListener('copy',cb)\r\ndocument.addEventListener('copy',cb)\r\n```",
      "reactions": {
        "totalCount": 0
      },
      "author": {
        "login": "nishuzumi",
        "url": "https://github.com/nishuzumi"
      }
    }
  },
  {
    "id": "MDU6SXNzdWU3NjEzNzkwNTI=",
    "number": 445,
    "title": "【Q438】数据库设计时 char 与 varchar 有什么区别",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
        "name": "db"
      }
    ],
    "comment": ""
  },
  {
    "id": "MDU6SXNzdWU3NjUyMTc2MDQ=",
    "number": 447,
    "title": "【Q439】JSONP 的原理是什么，如何实现",
    "body": "",
    "labels": [
      {
        "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
        "name": "js"
      }
    ],
    "comment": ""
  }
]